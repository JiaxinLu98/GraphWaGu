{"version":3,"file":"graphwagu-renderer.js","sources":["../src/webgpu/wgsl-shaders.ts","../src/webgpu/ez_canvas_controller.ts","../src/webgpu/sort.ts","../src/webgpu/force_directed.ts","../src/webgpu/utils.ts","../node_modules/file-saver/dist/FileSaver.min.js","../src/webgpu/render.ts"],"sourcesContent":["// Auto-generated file containing WGSL shaders as strings\n// Do not edit this file manually!\n\nexport const apply_forces = `struct Node {\r\n    value : f32,\r\n    x : f32,\r\n    y : f32,\r\n    size : f32,\r\n};\r\nstruct Nodes {\r\n    nodes : array<Node>,\r\n};\r\nstruct Forces {\r\n    forces : array<f32>,\r\n};\r\nstruct Batch {\r\n    batch_id : u32,\r\n};\r\nstruct Uniforms {\r\n    nodes_length : u32,\r\n    edges_length : u32,\r\n    cooling_factor : f32,\r\n    ideal_length : f32,\r\n};\r\nstruct Range {\r\n    x_min : atomic<i32>,\r\n    x_max : atomic<i32>,\r\n    y_min : atomic<i32>,\r\n    y_max : atomic<i32>,\r\n};\r\n@group(0) @binding(0) var<storage, read_write> nodes : Nodes;\r\n@group(0) @binding(1) var<storage, read_write> forces : Forces;\r\n// @group(0) @binding(2) var<uniform> batch : Batch;\r\n@group(0) @binding(2) var<uniform> uniforms : Uniforms;\r\n@group(0) @binding(3) var<storage, read_write> bounding : Range;\r\n\r\n@compute @workgroup_size(128, 1, 1)\r\nfn main(@builtin(global_invocation_id) global_id : vec3<u32>) {\r\n    if (global_id.x >= uniforms.nodes_length) {\r\n        return;\r\n    }\r\n    var high : f32 = 8.0;\r\n    var low : f32 = -7.0;\r\n    var batch_index : u32 = global_id.x;\r\n    for (var iter = 0u; iter < 2u; iter = iter + 1u) {\r\n        // nodes.nodes[batch_index].x = nodes.nodes[batch_index].x + forces.forces[batch_index * 2u];\r\n        // nodes.nodes[batch_index].y = nodes.nodes[batch_index].y + forces.forces[batch_index * 2u + 1u]; \r\n        if (forces.forces[batch_index * 2u] > uniforms.cooling_factor) {\r\n            // atomicStore(&bounding.y_max, i32(batch_index));\r\n            forces.forces[batch_index * 2u] = 0.0;    \r\n        }\r\n        if (forces.forces[batch_index * 2u + 1u] > uniforms.cooling_factor) {\r\n            // atomicStore(&bounding.y_min, i32(batch_index));\r\n            forces.forces[batch_index * 2u + 1u] = 0.0;    \r\n        }\r\n        // var x : f32 = min(high, max(low, nodes.nodes[batch_index].x + forces.forces[batch_index * 2u]));\r\n        // var y : f32 = min(high, max(low, nodes.nodes[batch_index].y + forces.forces[batch_index * 2u + 1u]));\r\n        var x : f32 = nodes.nodes[batch_index].x + forces.forces[batch_index * 2u];\r\n        var y : f32 = nodes.nodes[batch_index].y + forces.forces[batch_index * 2u + 1u];\r\n\r\n        // var centering : vec2<f32> = normalize(vec2<f32>(0.5, 0.5) - vec2<f32>(x, y));\r\n        // var dist : f32 = distance(vec2<f32>(0.5, 0.5), vec2<f32>(x, y));\r\n        // x = x + centering.x * (0.1 * uniforms.cooling_factor * dist);\r\n        // y = y + centering.y * (0.1 * uniforms.cooling_factor * dist);\r\n        // Randomize position slightly to prevent exact duplicates after clamping\r\n        // if (x == high) {\r\n        //     x = x - f32(batch_index) / 500000.0; \r\n        // } \r\n        // if (y == high) {\r\n        //     y = y - f32(batch_index) / 500000.0; \r\n        // }\r\n        // if (x == low) {\r\n        //     x = x + f32(batch_index) / 500000.0; \r\n        // }\r\n        // if (y == low) {\r\n        //     y = y + f32(batch_index) / 500000.0; \r\n        // }\r\n        nodes.nodes[batch_index].x = x;\r\n        nodes.nodes[batch_index].y = y;\r\n        forces.forces[batch_index * 2u] = 0.0;\r\n        forces.forces[batch_index * 2u + 1u] = 0.0;\r\n        atomicMin(&bounding.x_min, i32(floor(x * 1000.0)));\r\n        atomicMax(&bounding.x_max, i32(ceil(x * 1000.0)));\r\n        atomicMin(&bounding.y_min, i32(floor(y * 1000.0)));\r\n        atomicMax(&bounding.y_max, i32(ceil(y * 1000.0)));\r\n\r\n\r\n        // var test : f32 = forces.forces[0]; \r\n        // var test2 : f32 = nodes.nodes[0].x;\r\n        batch_index = batch_index + (uniforms.nodes_length / 2u);\r\n    }\r\n}\r\n`;\n\nexport const compute_attractive_new = `struct Node {\r\n    value : f32,\r\n    x : f32,\r\n    y : f32,\r\n    size : f32,\r\n};\r\nstruct Nodes {\r\n    nodes : array<Node>,\r\n};\r\nstruct Forces {\r\n    forces : array<f32>,\r\n};\r\nstruct UintArray {\r\n    a : array<u32>,\r\n};\r\nstruct EdgeInfo {\r\n    source_start : u32,\r\n    source_degree : u32,\r\n    dest_start : u32,\r\n    dest_degree : u32,\r\n}\r\nstruct EdgeInfoArray {\r\n    a : array<EdgeInfo>,\r\n};\r\nstruct Uniforms {\r\n    nodes_length : u32,\r\n    edges_length : u32,\r\n    cooling_factor : f32,\r\n    ideal_length : f32,\r\n};\r\n\r\n@group(0) @binding(0) var<storage, read_write> edge_info : EdgeInfoArray;\r\n@group(0) @binding(1) var<storage, read> source_list : UintArray;\r\n@group(0) @binding(2) var<storage, read> dest_list : UintArray;\r\n@group(0) @binding(3) var<storage, read_write> forces : Forces;\r\n@group(0) @binding(4) var<storage, read> nodes : Nodes;\r\n@group(0) @binding(5) var<uniform> uniforms : Uniforms;\r\n\r\n@compute @workgroup_size(128, 1, 1)\r\nfn main(@builtin(global_invocation_id) global_id : vec3<u32>) {\r\n    if (global_id.x >= uniforms.nodes_length) {\r\n        return;\r\n    }\r\n    let l : f32 = uniforms.ideal_length;\r\n    var node : Node = nodes.nodes[global_id.x];\r\n    var a_force : vec2<f32> = vec2<f32>(0.0, 0.0);\r\n    var info : EdgeInfo = edge_info.a[global_id.x];\r\n    // Accumulate forces where node is the source\r\n    for (var i : u32 = info.source_start; i < info.source_start + info.source_degree; i = i + 1u) {\r\n        var node2 : Node = nodes.nodes[source_list.a[i]];\r\n        var dist : f32 = distance(vec2<f32>(node.x, node.y), vec2<f32>(node2.x, node2.y));\r\n        if(dist > 0.0000001) {\r\n            var dir : vec2<f32> = normalize(vec2<f32>(node2.x, node2.y) - vec2<f32>(node.x, node.y));\r\n            a_force = a_force + ((dist * dist) / l) * dir;\r\n        }\r\n    }\r\n    // Accumulate forces where node is the dest\r\n    for (var i : u32 = info.dest_start; i < info.dest_start + info.dest_degree; i = i + 1u) {\r\n        var node2 : Node = nodes.nodes[dest_list.a[i]];\r\n        var dist : f32 = distance(vec2<f32>(node.x, node.y), vec2<f32>(node2.x, node2.y));\r\n        if(dist > 0.0000001) {\r\n            var dir : vec2<f32> = normalize(vec2<f32>(node2.x, node2.y) - vec2<f32>(node.x, node.y));\r\n            a_force = a_force + ((dist * dist) / l) * dir;\r\n        }\r\n    }\r\n    forces.forces[global_id.x * 2u] = a_force.x;\r\n    forces.forces[global_id.x * 2u + 1u] = a_force.y;\r\n}`;\n\nexport const compute_attract_forces = `struct Node {\r\n    value : f32,\r\n    x : f32,\r\n    y : f32,\r\n    size : f32,\r\n};\r\nstruct Nodes {\r\n    nodes : array<Node>,\r\n};\r\nstruct Edges {\r\n    edges : array<u32>,\r\n};\r\nstruct Forces {\r\n    forces : array<f32>,\r\n};\r\nstruct Uniforms {\r\n    nodes_length : u32,\r\n    edges_length : u32,\r\n    cooling_factor : f32,\r\n    ideal_length : f32,\r\n};\r\n\r\n@group(0) @binding(0) var<storage, read> nodes : Nodes;\r\n@group(0) @binding(1) var<storage, read> edges : Edges;\r\n@group(0) @binding(2) var<storage, read_write> forces : Forces;\r\n@group(0) @binding(3) var<uniform> uniforms : Uniforms;\r\n\r\n@compute @workgroup_size(1, 1, 1)\r\nfn main(@builtin(global_invocation_id) global_id : vec3<u32>) {\r\n    // let i : u32 = global_id.x;\r\n    let l : f32 = uniforms.ideal_length;\r\n    for (var i : u32 = 0u; i < uniforms.edges_length; i = i + 2u) {\r\n        var a_force : vec2<f32> = vec2<f32>(0.0, 0.0);\r\n        var node : Node = nodes.nodes[edges.edges[i]];\r\n        var node2 : Node = nodes.nodes[edges.edges[i + 1u]];\r\n        var dist : f32 = distance(vec2<f32>(node.x, node.y), vec2<f32>(node2.x, node2.y));\r\n        if(dist > 0.0) {\r\n            var dir : vec2<f32> = normalize(vec2<f32>(node2.x, node2.y) - vec2<f32>(node.x, node.y));\r\n            a_force = ((dist * dist) / l) * dir;\r\n            forces.forces[edges.edges[i] * 2u] = forces.forces[edges.edges[i] * 2u] + a_force.x;\r\n            forces.forces[edges.edges[i] * 2u + 1u] = forces.forces[edges.edges[i] * 2u + 1u] + a_force.y;\r\n            forces.forces[edges.edges[i + 1u] * 2u] = forces.forces[edges.edges[i + 1u] * 2u] - a_force.x;\r\n            forces.forces[edges.edges[i + 1u] * 2u + 1u] = forces.forces[edges.edges[i + 1u] * 2u + 1u] - a_force.y;\r\n        }\r\n    }\r\n}`;\n\nexport const compute_forces = `struct Node {\r\n    value : f32,\r\n    x : f32,\r\n    y : f32,\r\n    size : f32,\r\n};\r\nstruct Nodes {\r\n    nodes : array<Node>,\r\n};\r\nstruct Edges {\r\n    edges : array<u32>,\r\n};\r\nstruct Forces {\r\n    forces : array<f32>,\r\n};\r\nstruct Uniforms {\r\n    nodes_length : u32,\r\n    edges_length : u32,\r\n    cooling_factor : f32,\r\n    ideal_length : f32,\r\n};\r\n\r\n@group(0) @binding(0) var<storage, read> nodes : Nodes;\r\n@group(0) @binding(1) var<storage, read> adjmat : Edges;\r\n@group(0) @binding(2) var<storage, read_write> forces : Forces;\r\n@group(0) @binding(3) var<uniform> uniforms : Uniforms;\r\n\r\nfn get_bit_selector(bit_index : u32) -> u32 {\r\n    return 1u << bit_index;\r\n}\r\n\r\nfn get_nth_bit(packed : u32, bit_index : u32) -> u32 {\r\n    return packed & get_bit_selector(bit_index);\r\n}\r\n\r\n@compute @workgroup_size(1, 1, 1)\r\nfn main(@builtin(global_invocation_id) global_id : vec3<u32>) {\r\n    let l : f32 = uniforms.ideal_length;\r\n    let node : Node = nodes.nodes[global_id.x];\r\n    var r_force : vec2<f32> = vec2<f32>(0.0, 0.0);\r\n    var a_force : vec2<f32> = vec2<f32>(0.0, 0.0);\r\n    for (var i : u32 = 0u; i < uniforms.nodes_length; i = i + 1u) {\r\n        if (i == global_id.x) {\r\n            continue;\r\n        }\r\n        var node2 : Node = nodes.nodes[i];\r\n        var dist : f32 = distance(vec2<f32>(node.x, node.y), vec2<f32>(node2.x, node2.y));\r\n        if (dist > 0.0){\r\n            if (get_nth_bit(adjmat.edges[(i * uniforms.nodes_length + global_id.x) / 32u], (i * uniforms.nodes_length + global_id.x) % 32u) != 0u) {\r\n                var dir : vec2<f32> = normalize(vec2<f32>(node2.x, node2.y) - vec2<f32>(node.x, node.y));\r\n                a_force = a_force + ((dist * dist) / l) * dir;\r\n            } else {\r\n                var dir : vec2<f32> = normalize(vec2<f32>(node.x, node.y) - vec2<f32>(node2.x, node2.y));\r\n                r_force = r_force + ((l * l) / dist) * dir;\r\n            }\r\n        }\r\n    }\r\n    var force : vec2<f32> = (a_force + r_force);\r\n    var localForceMag: f32 = length(force); \r\n    if (localForceMag>0.000000001) {\r\n        force = normalize(force) * min(uniforms.cooling_factor, length(force));\r\n    }\r\n    else{\r\n        force.x = 0.0;\r\n        force.y = 0.0;\r\n    }\r\n    forces.forces[global_id.x * 2u] = force.x;\r\n    forces.forces[global_id.x * 2u + 1u] = force.y;\r\n}\r\n`;\n\nexport const compute_forcesBH = `const cluster_size = CHANGEMEu;\r\nstruct Node {\r\n    value : f32,\r\n    x : f32,\r\n    y : f32,\r\n    size : f32,\r\n};\r\nstruct Edges {\r\n    edges : array<u32>,\r\n};\r\nstruct Uniforms {\r\n    nodes_length : u32,\r\n    edges_length : u32,\r\n    cooling_factor : f32,\r\n    ideal_length : f32,\r\n};\r\nstruct TreeInfo {\r\n    step : u32,\r\n    max_index : u32,\r\n    theta : f32,\r\n};\r\nstruct Range {\r\n    x_min : i32,\r\n    x_max : i32,\r\n    y_min : i32,\r\n    y_max : i32,\r\n};\r\nstruct TreeNode {\r\n    // x, y, width, height\r\n    boundary : vec4<f32>,\r\n    CoM : vec2<f32>,\r\n    mass : f32,\r\n    test : u32,\r\n    code : u32,\r\n    level : u32,\r\n    test2: u32,\r\n    test3: u32,\r\n    pointers : array<u32, cluster_size>,\r\n};\r\n\r\n@group(0) @binding(0) var<storage, read> nodes : array<Node>;\r\n@group(0) @binding(1) var<storage, read_write> forces : array<f32>;\r\n@group(0) @binding(2) var<uniform> uniforms : Uniforms;\r\n@group(0) @binding(3) var<uniform> tree_info : TreeInfo;\r\n@group(0) @binding(4) var<storage, read> tree : array<TreeNode>;\r\n\r\n@compute @workgroup_size(128, 1, 1)\r\nfn main(@builtin(global_invocation_id) global_id : vec3<u32>) {\r\n    var stack = array<u32, 64>();\r\n    let l : f32 = uniforms.ideal_length;\r\n    var index : u32 = global_id.x;\r\n    if (index >= uniforms.nodes_length) {\r\n        return;\r\n    }\r\n    let node = nodes[index];\r\n    var theta : f32 = tree_info.theta;\r\n    var r_force : vec2<f32> = vec2<f32>(0.0, 0.0);\r\n    var a_force : vec2<f32> = vec2<f32>(forces[index * 2u], forces[index * 2u + 1u]);\r\n    var tree_idx : u32 = tree_info.max_index;\r\n    var counter : u32 = 0u;\r\n    var out : u32 = 0u;\r\n    loop {\r\n        out = out + 1u;\r\n        // if (out == 1000u) {\r\n        //     break;\r\n        // }\r\n        var tree_node = tree[tree_idx];\r\n        let dist : f32 = distance(vec2<f32>(node.x, node.y), tree_node.CoM);\r\n        let s : f32 = 2.0 * tree_node.boundary.w;\r\n        if (theta > s / dist) {\r\n            var dir : vec2<f32> = normalize(vec2<f32>(node.x, node.y) - tree_node.CoM);\r\n            r_force = r_force + tree_node.mass * ((l * l) / dist) * dir;\r\n        } else {\r\n            for (var i : u32 = 0u; i < cluster_size; i = i + 1u) {\r\n                let child : u32 = tree_node.pointers[i];\r\n                if (child == 0 || tree[child].mass < 1.0) {\r\n                    continue;\r\n                } else {\r\n                    if (tree[child].mass > 1.0) {\r\n                        stack[counter] = child;\r\n                        counter = counter + 1u;\r\n                    } else {\r\n                        let dist : f32 = distance(vec2<f32>(node.x, node.y), tree[child].CoM);\r\n                        if (dist > 0.0) {\r\n                            var dir : vec2<f32> = normalize(vec2<f32>(node.x, node.y) - tree[child].CoM);\r\n                            r_force = r_force + ((l * l) / dist) * dir;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        counter--;\r\n        if (counter < 0u) {\r\n            break;\r\n        }\r\n        tree_idx = stack[counter];\r\n        if (tree_idx == 0u) {\r\n            break;\r\n        } \r\n    }\r\n    var force : vec2<f32> = (a_force + r_force);\r\n    var localForceMag: f32 = length(force); \r\n    if (localForceMag>0.000000001) {\r\n        force = normalize(force) * min(uniforms.cooling_factor, length(force));\r\n    }\r\n    else{\r\n        force.x = 0.0;\r\n        force.y = 0.0;\r\n    }\r\n    if (force.x > uniforms.cooling_factor) {\r\n        force.x = 0.0;\r\n    }\r\n    if (force.y > uniforms.cooling_factor) {\r\n        force.y = 0.0;\r\n    }\r\n    forces[index * 2u] = force.x;\r\n    forces[index * 2u + 1u] = force.y;\r\n}\r\n`;\n\nexport const create_adjacency_matrix = `struct Edges {\r\n    edges : array<u32>,\r\n};\r\nstruct BoolArray {\r\n    matrix : array<u32>,\r\n};\r\nstruct Uniforms {\r\n    nodes_length : u32,\r\n    edges_length : u32,\r\n    cooling_factor : f32,\r\n    ideal_length : f32,\r\n};\r\nstruct IntArray {\r\n    matrix : array<i32>,\r\n};\r\n\r\n@group(0) @binding(0) var<storage, read> edges : Edges;\r\n@group(0) @binding(1) var<storage, read_write> adjmat : BoolArray;\r\n@group(0) @binding(2) var<uniform> uniforms : Uniforms;\r\n@group(0) @binding(3) var<storage, read_write> laplacian : IntArray;\r\n\r\nfn get_bit_selector(bit_index : u32) -> u32 {\r\n    return 1u << bit_index;\r\n}\r\n\r\nfn set_nth_bit(packed : u32, bit_index : u32) -> u32{\r\n    return packed | get_bit_selector(bit_index);\r\n}\r\n\r\n@compute @workgroup_size(1, 1, 1)\r\nfn main(@builtin(global_invocation_id) global_id : vec3<u32>) {\r\n    for (var i : u32 = 0u; i < uniforms.edges_length; i = i + 2u) {\r\n        var source : u32 = edges.edges[i];\r\n        var dest : u32 = edges.edges[i + 1u];\r\n        adjmat.matrix[(source * uniforms.nodes_length + dest) / 32u] = set_nth_bit(adjmat.matrix[(source * uniforms.nodes_length + dest) / 32u], (source * uniforms.nodes_length + dest) % 32u);\r\n        adjmat.matrix[(dest * uniforms.nodes_length + source) / 32u] = set_nth_bit(adjmat.matrix[(dest * uniforms.nodes_length + source) / 32u], (dest * uniforms.nodes_length + source) % 32u);\r\n        // if (laplacian.matrix[source * uniforms.nodes_length + dest] != -1 && source != dest) {\r\n        //     laplacian.matrix[source * uniforms.nodes_length + dest] = -1;\r\n        //     laplacian.matrix[dest * uniforms.nodes_length + source] = -1;\r\n        //     laplacian.matrix[source * uniforms.nodes_length + source] = laplacian.matrix[source * uniforms.nodes_length + source] + 1;\r\n        //     laplacian.matrix[dest * uniforms.nodes_length + dest] = laplacian.matrix[dest * uniforms.nodes_length + dest] + 1;\r\n        // }\r\n    } \r\n}\r\n`;\n\nexport const create_sourcelist = `struct Edges {\r\n    edges : array<u32>,\r\n};\r\nstruct UintArray {\r\n    a : array<u32>,\r\n};\r\nstruct EdgeInfo {\r\n    source_start : u32,\r\n    source_degree : u32,\r\n    dest_start : u32,\r\n    dest_degree : u32,\r\n}\r\nstruct EdgeInfoArray {\r\n    a : array<EdgeInfo>,\r\n};\r\nstruct Uniforms {\r\n    nodes_length : u32,\r\n    edges_length : u32,\r\n    cooling_factor : f32,\r\n    ideal_length : f32,\r\n};\r\n\r\n@group(0) @binding(0) var<storage, read_write> edges : Edges;\r\n@group(0) @binding(1) var<storage, read_write> edge_info : EdgeInfoArray;\r\n@group(0) @binding(2) var<storage, read_write> source_list : UintArray;\r\n@group(0) @binding(3) var<uniform> uniforms : Uniforms;\r\n\r\n@compute @workgroup_size(1, 1, 1)\r\nfn main(@builtin(global_invocation_id) global_id : vec3<u32>) {\r\n    var counter : u32 = 0u;\r\n    var source : u32 = 0u;\r\n    // expects edges to be sorted by source id\r\n    for (var i : u32 = 0u; i < uniforms.edges_length; i = i + 2u) {\r\n        var new_source : u32 = edges.edges[i];\r\n        var dest : u32 = edges.edges[i + 1u];\r\n        edge_info.a[new_source].source_degree = edge_info.a[new_source].source_degree + 1u;\r\n        source_list.a[counter] = dest;\r\n        if (new_source != source || i == 0u) {\r\n            edge_info.a[new_source].source_start = counter;\r\n        }\r\n        counter = counter + 1u;\r\n        source = new_source;\r\n    }\r\n}`;\n\nexport const create_targetlist = `struct Edges {\r\n    edges : array<u32>,\r\n};\r\nstruct UintArray {\r\n    a : array<u32>,\r\n};\r\nstruct EdgeInfo {\r\n    source_start : u32,\r\n    source_degree : u32,\r\n    dest_start : u32,\r\n    dest_degree : u32,\r\n}\r\nstruct EdgeInfoArray {\r\n    a : array<EdgeInfo>,\r\n};\r\nstruct Uniforms {\r\n    nodes_length : u32,\r\n    edges_length : u32,\r\n    cooling_factor : f32,\r\n    ideal_length : f32,\r\n};\r\n\r\n@group(0) @binding(0) var<storage, read_write> edges : Edges;\r\n@group(0) @binding(1) var<storage, read_write> edge_info : EdgeInfoArray;\r\n@group(0) @binding(2) var<storage, read_write> dest_list : UintArray;\r\n@group(0) @binding(3) var<uniform> uniforms : Uniforms;\r\n\r\n@compute @workgroup_size(1, 1, 1)\r\nfn main(@builtin(global_invocation_id) global_id : vec3<u32>) {\r\n    var counter : u32 = 0u;\r\n    var dest : u32 = 0u;\r\n    // expects edges to be sorted by dest id\r\n    for (var i : u32 = 0u; i < uniforms.edges_length; i = i + 2u) {\r\n        var source : u32 = edges.edges[i];\r\n        var new_dest : u32 = edges.edges[i + 1u];\r\n        edge_info.a[new_dest].dest_degree = edge_info.a[new_dest].dest_degree + 1u;\r\n        dest_list.a[counter] = source;\r\n        if (new_dest != dest || i == 0u) {\r\n            edge_info.a[new_dest].dest_start = counter;\r\n        }\r\n        counter = counter + 1u;\r\n        dest = new_dest;\r\n    }\r\n}`;\n\nexport const create_tree = `const cluster_size = CHANGEMEu;\r\nstruct Node {\r\n    value : f32,\r\n    x : f32,\r\n    y : f32,\r\n    size : f32,\r\n};\r\nstruct Uniforms {\r\n    nodes_length : u32,\r\n    edges_length : u32,\r\n    cooling_factor : f32,\r\n    ideal_length : f32,\r\n};\r\nstruct TreeInfo {\r\n    step : u32,\r\n    max_index : u32,\r\n    theta: f32,\r\n    cluster_size: u32,\r\n};\r\nstruct Range {\r\n    x_min : i32,\r\n    x_max : i32,\r\n    y_min : i32,\r\n    y_max : i32,\r\n};\r\nstruct TreeNode {\r\n    // x, y, width, height\r\n    boundary : vec4<f32>,\r\n    CoM : vec2<f32>,\r\n    mass : f32,\r\n    test : u32,\r\n    code : u32,\r\n    level : u32,\r\n    test2: u32,\r\n    test3: u32,\r\n    pointers : array<u32, cluster_size>,\r\n};\r\n\r\n@group(0) @binding(0) var<storage, read> indices : array<u32>;\r\n@group(0) @binding(1) var<uniform> uniforms : Uniforms;\r\n@group(0) @binding(2) var<uniform> tree_info : TreeInfo;\r\n@group(0) @binding(3) var<storage, read_write> bounding : Range;\r\n@group(0) @binding(4) var<storage, read_write> tree : array<TreeNode>;\r\n\r\n// Find the level above where two Morton codes first disagree\r\nfn find_morton_split_level(morton1: u32, morton2: u32) -> u32 {\r\n    // XOR the Morton codes to find differing bits\r\n    let diff = morton1 ^ morton2;\r\n    \r\n    // If codes are identical, return 16\r\n    if (diff == 0u) {\r\n        return 16u;\r\n    }\r\n    \r\n    // Find position of highest different bit\r\n    var highest_diff_bit = 31u;\r\n    var temp = diff;\r\n    \r\n    // Count leading zeros\r\n    while ((temp & 0x80000000u) == 0u) {\r\n        temp = temp << 1u;\r\n        highest_diff_bit = highest_diff_bit - 1u;\r\n    }\r\n    \r\n    // Convert bit position to level\r\n    let level = 16u - (highest_diff_bit + 2u) / 2u;\r\n    return level;\r\n}\r\n\r\n@compute @workgroup_size(128, 1, 1)\r\nfn main(@builtin(global_invocation_id) global_id : vec3<u32>) {\r\n    let x_min = f32(bounding.x_min) / 1000.0;\r\n    let x_max = f32(bounding.x_max) / 1000.0;\r\n    let y_min = f32(bounding.y_min) / 1000.0;\r\n    let y_max = f32(bounding.y_max) / 1000.0;\r\n    let step = tree_info.step;\r\n    var idx = global_id.x * cluster_size;\r\n    var start = f32(uniforms.nodes_length);\r\n    var end = uniforms.nodes_length;\r\n    for (var i = 0u; i < step; i++) {\r\n        idx += u32(start);\r\n        start = ceil(start / f32(cluster_size));\r\n        end += u32(start);\r\n    }\r\n    if (idx >= end) {\r\n        return;\r\n    }\r\n    var pointers = array<u32, cluster_size>();\r\n    if (step == 0u) {\r\n        for (var i = 0u; i < cluster_size; i++) {\r\n            if (idx + i >= end) {\r\n                pointers[i] = 0;\r\n            } else {\r\n                pointers[i] = indices[idx + i] + 1;\r\n            }\r\n        }\r\n    } else {\r\n        for (var i = 0u; i < cluster_size; i++) {\r\n             if (idx + i >= end) {\r\n                pointers[i] = 0;\r\n            } else {\r\n                pointers[i] = idx + i + 1;\r\n            }\r\n        }\r\n    }\r\n    var node = tree[pointers[0]];\r\n    var code = node.code;\r\n    var level = node.level;\r\n    var mass = node.mass;\r\n    var CoM = node.CoM;\r\n    for (var i = 1u; i < cluster_size; i++) {\r\n        if (idx + i >= end) {\r\n            break;\r\n        }\r\n        node = tree[pointers[i]];\r\n        level = min(find_morton_split_level(code, node.code), min(level, node.level));\r\n        CoM = (mass * CoM + node.mass * node.CoM) / (mass + node.mass);\r\n        mass = mass + node.mass;\r\n    }\r\n    tree[end + global_id.x + 1] = TreeNode(\r\n        vec4<f32>(0.0, 0.0, (1.0 / f32(1u << level)) * (x_max - x_min), (1.0 / f32(1u << level)) * (y_max - y_min)),\r\n        CoM,\r\n        mass, \r\n        0u, \r\n        code, level, 0u, 0u,\r\n        pointers,\r\n    );\r\n    //  PROBLEM WITH POINTERS ARRAY\r\n    // let node1 = tree[pointers[0]];\r\n    // let node2 = tree[pointers[1]];\r\n    // let node3 = tree[pointers[2]];\r\n    // let node4 = tree[pointers[3]];\r\n    // let morton1 = node1.code;\r\n    // let morton2 = node2.code;\r\n    // let morton3 = node3.code;\r\n    // let morton4 = node4.code;\r\n    // if (idx == end - 1) {\r\n    //     // Just write the node out without merging with anything\r\n    //     tree[end + global_id.x + 1] = node1;\r\n    //     return;\r\n    // }\r\n    // if (idx == end - 2) {\r\n    //     let level = min(find_morton_split_level(morton1, morton2), min(node1.level, node2.level));\r\n    //     tree[end + global_id.x + 1] = TreeNode(\r\n    //         vec4<f32>(0.0, 0.0, 1.0 / f32(1u << level), 1.0 / f32(1u << level)),\r\n    //         (node1.mass * node1.CoM + node2.mass * node2.CoM) / (node1.mass + node2.mass),\r\n    //         node1.mass + node2.mass, \r\n    //         morton2, \r\n    //         pointers,\r\n    //         morton1, level\r\n    //     );\r\n    //     return;\r\n    // }\r\n    // if (idx == end - 3) {\r\n    //     let level = min(min(find_morton_split_level(morton3, morton2), min(find_morton_split_level(morton1, morton2), min(node1.level, node2.level))), node3.level);\r\n    //     tree[end + global_id.x + 1] = TreeNode(\r\n    //         vec4<f32>(0.0, 0.0, 1.0 / f32(1u << level), 1.0 / f32(1u << level)),\r\n    //         (node1.mass * node1.CoM + node2.mass * node2.CoM + node3.mass * node3.CoM) / (node1.mass + node2.mass + node3.mass),\r\n    //         node1.mass + node2.mass + node3.mass, \r\n    //         morton2, \r\n    //         pointers,\r\n    //         morton1, level\r\n    //     );\r\n    //     return;\r\n    // }\r\n    // let level12 = min(find_morton_split_level(morton1, morton2), min(node1.level, node2.level));\r\n    // let level34 = min(find_morton_split_level(morton3, morton4), min(node3.level, node4.level));\r\n    // let level = min(find_morton_split_level(morton2, morton3), min(level12, level34));\r\n    // tree[end + global_id.x + 1] = TreeNode(\r\n    //     vec4<f32>(0.0, 0.0, 1.0 / f32(1u << level), 1.0 / f32(1u << level)),\r\n    //     (node1.mass * node1.CoM + node2.mass * node2.CoM + node3.mass * node3.CoM + node4.mass * node4.CoM) / (node1.mass + node2.mass + node3.mass + node4.mass),\r\n    //     node1.mass + node2.mass + node3.mass + node4.mass, \r\n    //     morton2, \r\n    //     pointers,\r\n    //     morton1, level\r\n    // );\r\n}\r\n`;\n\nexport const edge_frag = `@fragment\r\nfn main()->@location(0) vec4<f32>{\r\n    return vec4<f32>(0.0, 0.0, 0.0, 0.1);\r\n}`;\n\nexport const edge_vert = `//this builtin(position) clip_position tells that clip_position is the value we want to use for our vertex position or clip position\r\n//it's not needed to create a struct, we could just do [[builtin(position)]] clipPosition\r\nstruct VertexOutput{\r\n    @builtin(position) clip_position: vec4<f32>,\r\n};\r\nstruct Uniforms {\r\n  view_box : vec4<f32>,\r\n};\r\nstruct Node {\r\n    value : f32,\r\n    x : f32,\r\n    y : f32,\r\n    size : f32,\r\n};\r\nstruct Nodes {\r\n    nodes : array<Node>,\r\n};\r\nstruct Edges {\r\n    edges : array<u32>,\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> uniforms : Uniforms;\r\n@group(0) @binding(1) var<storage, read> nodes : Nodes;\r\n@group(0) @binding(2) var<storage, read> edges : Edges;\r\n@vertex\r\nfn main(@builtin(instance_index) index : u32, @location(0) position: vec2<f32>)-> VertexOutput {\r\n    var out : VertexOutput;\r\n    var node : Node = nodes.nodes[edges.edges[2u * index + u32(position.x)]];\r\n    var inv_zoom : f32 = uniforms.view_box.z - uniforms.view_box.x;\r\n    var expected_x : f32 = 0.5 * (1.0 - inv_zoom); \r\n    var expected_y : f32 = 0.5 * (1.0 - inv_zoom);\r\n    // view_box expected to be between 0 and 1, panning need to be doubled as clip space is (-1, 1)\r\n    var x : f32 = ((2.0 * node.x - 1.0) - 2.0 * (uniforms.view_box.x - expected_x)) / inv_zoom;\r\n    var y : f32 = ((2.0 * node.y - 1.0) - 2.0 * (uniforms.view_box.y - expected_y)) / inv_zoom;\r\n    out.clip_position = vec4<f32>(x, y, 0.0, 1.0);\r\n    return out;\r\n}`;\n\nexport const morton_codes = `const cluster_size = CHANGEMEu;\r\nstruct Node {\r\n    value : f32,\r\n    x : f32,\r\n    y : f32,\r\n    size : f32,\r\n};\r\nstruct Uniforms {\r\n    nodes_length : u32,\r\n    edges_length : u32,\r\n    cooling_factor : f32,\r\n    ideal_length : f32,\r\n};\r\nstruct Range {\r\n    x_min : i32,\r\n    x_max : i32,\r\n    y_min : i32,\r\n    y_max : i32,\r\n};\r\nstruct TreeNode {\r\n    // x, y, width, height\r\n    boundary : vec4<f32>,\r\n    CoM : vec2<f32>,\r\n    mass : f32,\r\n    test : u32,\r\n    code : u32,\r\n    level : u32,\r\n    test2: u32,\r\n    test3: u32,\r\n    pointers : array<u32, cluster_size>,\r\n};\r\n\r\n@group(0) @binding(0) var<storage, read> nodes : array<Node>;\r\n@group(0) @binding(1) var<storage, read_write> morton_codes : array<u32>;\r\n@group(0) @binding(2) var<uniform> uniforms : Uniforms;\r\n@group(0) @binding(3) var<storage, read_write> bounding : Range;\r\n@group(0) @binding(4) var<storage, read_write> morton_indices : array<u32>;\r\n@group(0) @binding(5) var<storage, read_write> tree : array<TreeNode>;\r\n\r\n// Spreads bits by inserting 0s between each bit\r\nfn spread_bits(x: u32) -> u32 {\r\n    var x_mut = x & 0x0000FFFF;  // Mask to ensure we only use lower 16 bits\r\n    x_mut = (x_mut | (x_mut << 8)) & 0x00FF00FF;\r\n    x_mut = (x_mut | (x_mut << 4)) & 0x0F0F0F0F;\r\n    x_mut = (x_mut | (x_mut << 2)) & 0x33333333;\r\n    x_mut = (x_mut | (x_mut << 1)) & 0x55555555;\r\n    return x_mut;\r\n}\r\n\r\n// Converts float in [0,1] to fixed-point integer\r\n// TODO: precision lost here\r\nfn float_to_fixed(f: f32) -> u32 {\r\n    return u32(f * 65535.0);  // 2^16 - 1\r\n}\r\n\r\n// Convert morton code to quadrant boundaries\r\nfn morton_to_rectangle(morton: u32, level: u32) -> vec4<f32> {    \r\n    // Initialize normalized coordinates\r\n    var x = 0.0;\r\n    var y = 0.0;\r\n    var size = 1.0;\r\n    \r\n    // Process each pair of bits from most significant to least\r\n    for(var i = 0u; i < level; i++) {\r\n        size *= 0.5; // Each level divides size by 2\r\n        let shift = (15u - i) * 2u;\r\n        let bits = (morton >> shift) & 3u; // Get pair of bits\r\n        \r\n        // Update position based on quadrant\r\n        switch bits {\r\n            case 0u: { // 00: bottom left\r\n                // Position stays the same\r\n            }\r\n            case 1u: { // 01: bottom right\r\n                x += size;\r\n            }\r\n            case 2u: { // 10: top left\r\n                y += size;\r\n            }\r\n            case 3u: { // 11: top right\r\n                x += size;\r\n                y += size;\r\n            }\r\n            default: {}\r\n        }\r\n    }\r\n    \r\n    // Convert from normalized coordinates to world space\r\n    let x_min = f32(bounding.x_min) / 1000.0;\r\n    let x_max = f32(bounding.x_max) / 1000.0;\r\n    let y_min = f32(bounding.y_min) / 1000.0;\r\n    let y_max = f32(bounding.y_max) / 1000.0;\r\n    \r\n    let world_x = x * (x_max - x_min) + x_min;\r\n    let world_y = y * (y_max - y_min) + y_min;\r\n    let world_w = size * (x_max - x_min);\r\n    let world_h = size * (y_max - y_min);\r\n    \r\n    return vec4<f32>(world_x, world_y, world_w, world_h);\r\n}\r\n\r\nfn rotate_bits(n: u32, rx: u32, ry: u32, order: u32) -> u32 {\r\n    if (ry == 0u) {\r\n        if (rx == 1u) {\r\n            // Reflect about y=x\r\n            let mask = (1u << order) - 1u;\r\n            return mask - n;\r\n        }\r\n    }\r\n    return n;\r\n}\r\n\r\nfn hilbert_xy_to_d(x_in: u32, y_in: u32) -> u32 {\r\n    var d: u32 = 0u;\r\n    var x: u32 = x_in;\r\n    var y: u32 = y_in;\r\n    var rx: u32;\r\n    var ry: u32;\r\n    \r\n    // Process 16 bits of input coordinates\r\n    for(var i: u32 = 0u; i < 16u; i += 1u) {\r\n        let s = 15u - i;\r\n        \r\n        // Extract current bit of x and y from highest positions\r\n        rx = (x >> 15u) & 1u;\r\n        ry = (y >> 15u) & 1u;\r\n        \r\n        // Add position to result\r\n        d |= ((3u * rx) ^ ry) << (2u * s);\r\n        \r\n        // Rotate coordinates if needed for next iteration\r\n        if (ry == 0u) {\r\n            if (rx == 1u) {\r\n                // Reflect about y=x\r\n                x = (1u << 16u) - 1u - x;\r\n                y = (1u << 16u) - 1u - y;\r\n            }\r\n            // Swap x and y\r\n            let t = x;\r\n            x = y;\r\n            y = t;\r\n        }\r\n        \r\n        // Shift coordinates for next iteration\r\n        x = (x << 1u) & 0xFFFFu;\r\n        y = (y << 1u) & 0xFFFFu;\r\n    }\r\n    \r\n    return d;\r\n}\r\n\r\n@compute @workgroup_size(128, 1, 1)\r\nfn main(@builtin(global_invocation_id) global_id : vec3<u32>) {\r\n    let idx = global_id.x;\r\n    if (idx >= uniforms.nodes_length) {\r\n        return;\r\n    }\r\n    let node = nodes[idx];\r\n    \r\n    // Convert floats to fixed-point\r\n    let x_min = f32(bounding.x_min) / 1000.0;\r\n    let x_max = f32(bounding.x_max) / 1000.0;\r\n    let y_min = f32(bounding.y_min) / 1000.0;\r\n    let y_max = f32(bounding.y_max) / 1000.0;\r\n    let x_fixed = float_to_fixed((node.x - x_min) / (x_max - x_min));\r\n    let y_fixed = float_to_fixed((node.y - y_min) / (y_max - y_min));\r\n    \r\n    // Compute Morton code by interleaving bits\r\n    let morton = spread_bits(x_fixed) | (spread_bits(y_fixed) << 1);\r\n    let hilbert = hilbert_xy_to_d(x_fixed, y_fixed);\r\n    let code = hilbert;\r\n    \r\n    morton_codes[idx] = code;\r\n    // morton_codes[idx] = morton;\r\n    morton_indices[idx] = idx;\r\n    // tree[idx + 1u] = TreeNode(\r\n    //     morton_to_rectangle(morton, 16),\r\n    //     vec2<f32>(node.x, node.y),\r\n    //     1.0, 0.0, vec4<u32>(0u),\r\n    //     morton, 16u\r\n    // );\r\n    tree[idx + 1u] = TreeNode(\r\n        vec4<f32>(0.0, 0.0, (1.0 / f32(1u << 16u)) * (x_max - x_min), (1.0 / f32(1u << 16u)) * (y_max - y_min)),\r\n        vec2<f32>(node.x, node.y),\r\n        1.0, 0u,\r\n        code, 16u, 0u, 0u,\r\n        array<u32, cluster_size>()\r\n    );\r\n}\r\n`;\n\nexport const node_frag = `fn sigmoid(x: f32) -> f32 {\r\n    return 1.0 / (1.0 + exp(-1.0 * x));\r\n}\r\n\r\n@fragment\r\nfn main(@location(0) position: vec2<f32>, @location(1) @interpolate(flat) center: vec2<f32>, @location(2) color: vec3<f32>) -> @location(0) vec4<f32> {\r\n    if (distance(position, center) > 0.002) {\r\n        discard;\r\n    }\r\n    return vec4<f32>(color.x, color.y, color.z, 1.0);\r\n}\r\n`;\n\nexport const node_vert = `struct Node {\r\n    value : f32,\r\n    x : f32,\r\n    y : f32,\r\n    size : f32,\r\n};\r\nstruct Nodes {\r\n    nodes : array<Node>,\r\n};\r\nstruct VertexOutput {\r\n    @builtin(position) Position : vec4<f32>,\r\n    @location(0) position: vec2<f32>,\r\n    @location(1) @interpolate(flat) center : vec2<f32>,\r\n    @location(2) color: vec3<f32>,\r\n};\r\nstruct Uniforms {\r\n  view_box : vec4<f32>,\r\n};\r\nstruct Edges {\r\n    edges : array<u32>,\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> uniforms : Uniforms;\r\n@group(0) @binding(1) var<storage, read> nodes : Nodes;\r\n@group(0) @binding(2) var<storage, read> morton_codes : array<u32>;\r\n\r\nfn u32_to_color(value: u32) -> vec3<f32> {\r\n    // First convert u32 to f32 in [0,1] range\r\n    // We need to be careful about precision here\r\n    // Break the u32 into two parts to maintain precision\r\n    let upper = f32(value >> 16u);\r\n    let lower = f32(value & 0xFFFFu);\r\n    \r\n    // Combine the parts with appropriate scaling\r\n    let normalized = (upper * 65536.0 + lower) / 4294967295.0;\r\n    \r\n    // Define the color gradient\r\n    // Here we'll use a simple RGB gradient: blue -> cyan -> green -> yellow -> red\r\n    let positions = array<f32, 5>(0.0, 0.25, 0.5, 0.75, 1.0);\r\n    let colors = array<vec3<f32>, 5>(\r\n        vec3<f32>(0.0, 0.0, 1.0),  // Blue\r\n        vec3<f32>(0.0, 1.0, 1.0),  // Cyan\r\n        vec3<f32>(0.0, 1.0, 0.0),  // Green\r\n        vec3<f32>(1.0, 1.0, 0.0),  // Yellow\r\n        vec3<f32>(1.0, 0.0, 0.0)   // Red\r\n    );\r\n    \r\n    // Find the segment\r\n    var i = 0;\r\n    while i < 4 && normalized > positions[i + 1] {\r\n        i = i + 1;\r\n    }\r\n    \r\n    // Calculate interpolation factor\r\n    let t = (normalized - positions[i]) / (positions[i + 1] - positions[i]);\r\n    \r\n    // Interpolate between colors\r\n    let color = mix(colors[i], colors[i + 1], t);\r\n    \r\n    return color;\r\n}\r\n\r\n@vertex\r\nfn main(@builtin(instance_index) index : u32, @location(0) position : vec2<f32>)\r\n     -> VertexOutput {\r\n    var node_center : vec2<f32> = 2.0 * vec2<f32>(nodes.nodes[index].x, nodes.nodes[index].y) - vec2<f32>(1.0);\r\n    var translation : vec2<f32> = position * 0.01;\r\n    var out_position : vec2<f32> = node_center + translation;\r\n    var output : VertexOutput;\r\n    var inv_zoom : f32 = uniforms.view_box.z - uniforms.view_box.x;\r\n    var expected_x : f32 = 0.5 * (1.0 - inv_zoom); \r\n    var expected_y : f32 = 0.5 * (1.0 - inv_zoom);\r\n    // view_box expected to be between 0 and 1, panning need to be doubled as clip space is (-1, 1)\r\n    var x : f32 = (out_position.x - 2.0 * (uniforms.view_box.x - expected_x)) / inv_zoom;\r\n    var y : f32 = (out_position.y - 2.0 * (uniforms.view_box.y - expected_y)) / inv_zoom;\r\n    output.Position = vec4<f32>(x, y, 0.0, 1.0);\r\n    output.position = out_position;\r\n    // flat interpolated position will give bottom right corner, so translate to center\r\n    output.center = node_center;\r\n    let test = morton_codes[index];\r\n    output.color = u32_to_color(test);\r\n    return output;\r\n}`;\n\nexport const radix_sort = `// shader implementing gpu radix sort. More information in the beginning of gpu_rs.rs\r\n// info: \r\n\r\n// also the workgroup sizes are added in these prepasses\r\n// before the pipeline is started the following constant definitionis are prepended to this shadercode\r\n\r\n// const histogram_sg_size\r\n// const histogram_wg_size\r\n// const rs_radix_log2\r\n// const rs_radix_size\r\n// const rs_keyval_size\r\n// const rs_histogram_block_rows\r\n// const rs_scatter_block_rows\r\n\r\nstruct GeneralInfo {\r\n    num_keys: u32,\r\n    padded_size: u32,\r\n    even_pass: u32,\r\n    odd_pass: u32,\r\n};\r\n\r\n@group(0) @binding(0)\r\nvar<storage, read_write> infos: GeneralInfo;\r\n@group(0) @binding(1)\r\nvar<storage, read_write> histograms : array<atomic<u32>>;\r\n@group(0) @binding(2)\r\nvar<storage, read_write> keys : array<u32>;\r\n@group(0) @binding(3)\r\nvar<storage, read_write> keys_b : array<u32>;\r\n@group(0) @binding(4)\r\nvar<storage, read_write> payload_a : array<u32>;\r\n@group(0) @binding(5)\r\nvar<storage, read_write> payload_b : array<u32>;\r\n\r\n// layout of the histograms buffer\r\n//   +---------------------------------+ <-- 0\r\n//   | histograms[keyval_size]         |\r\n//   +---------------------------------+ <-- keyval_size                           * histo_size\r\n//   | partitions[scatter_blocks_ru-1] |\r\n//   +---------------------------------+ <-- (keyval_size + scatter_blocks_ru - 1) * histo_size\r\n//   | workgroup_ids[keyval_size]      |\r\n//   +---------------------------------+ <-- (keyval_size + scatter_blocks_ru - 1) * histo_size + workgroup_ids_size\r\n\r\n// --------------------------------------------------------------------------------------------------------------\r\n// Filling histograms and keys with default values (also resets the pass infos for odd and even scattering)\r\n// --------------------------------------------------------------------------------------------------------------\r\n@compute @workgroup_size({histogram_wg_size})\r\nfn zero_histograms(@builtin(global_invocation_id) gid: vec3<u32>, @builtin(num_workgroups) nwg: vec3<u32>) {\r\n    if gid.x == 0u {\r\n        infos.even_pass = 0u;\r\n        infos.odd_pass = 1u;    // has to be one, as on the first call to even pass + 1 % 2 is calculated\r\n    }\r\n    // here the histograms are set to zero and the partitions are set to 0xfffffffff to avoid sorting problems\r\n    let scatter_wg_size = histogram_wg_size;\r\n    let scatter_block_kvs = scatter_wg_size * rs_scatter_block_rows;\r\n    let scatter_blocks_ru = (infos.num_keys + scatter_block_kvs - 1u) / scatter_block_kvs;\r\n\r\n    let histo_size = rs_radix_size;\r\n    var n = (rs_keyval_size + scatter_blocks_ru - 1u) * histo_size;\r\n    let b = n;\r\n    if infos.num_keys < infos.padded_size {\r\n        n += infos.padded_size - infos.num_keys;\r\n    }\r\n\r\n    let line_size = nwg.x * {histogram_wg_size}u;\r\n    for (var cur_index = gid.x; cur_index < n; cur_index += line_size){\r\n        if cur_index >= n {\r\n            return;\r\n        }\r\n            \r\n        if cur_index  < rs_keyval_size * histo_size {\r\n            atomicStore(&histograms[cur_index], 0u);\r\n        }\r\n        else if cur_index < b {\r\n            atomicStore(&histograms[cur_index], 0u);\r\n        }\r\n        else {\r\n            keys[infos.num_keys + cur_index - b] = 0xFFFFFFFFu;\r\n        }\r\n    }\r\n}\r\n\r\n// --------------------------------------------------------------------------------------------------------------\r\n// Calculating the histograms\r\n// --------------------------------------------------------------------------------------------------------------\r\nvar<workgroup> smem : array<atomic<u32>, rs_radix_size>;\r\nvar<private> kv : array<u32, rs_histogram_block_rows>;\r\nfn zero_smem(lid: u32) {\r\n    if lid < rs_radix_size {\r\n        atomicStore(&smem[lid], 0u);\r\n    }\r\n}\r\nfn histogram_pass(pass_: u32, lid: u32) {\r\n    zero_smem(lid);\r\n    workgroupBarrier();\r\n\r\n    for (var j = 0u; j < rs_histogram_block_rows; j++) {\r\n        let u_val = bitcast<u32>(kv[j]);\r\n        let digit = extractBits(u_val, pass_ * rs_radix_log2, rs_radix_log2);\r\n        atomicAdd(&smem[digit], 1u);\r\n    }\r\n\r\n    workgroupBarrier();\r\n    let histogram_offset = rs_radix_size * pass_ + lid;\r\n    if lid < rs_radix_size && atomicLoad(&smem[lid]) >= 0u {\r\n        atomicAdd(&histograms[histogram_offset], atomicLoad(&smem[lid]));\r\n    }\r\n}\r\n\r\n// the workgrpu_size can be gotten on the cpu by by calling pipeline.get_bind_group_layout(0).unwrap().get_local_workgroup_size();\r\nfn fill_kv(wid: u32, lid: u32) {\r\n    let rs_block_keyvals: u32 = rs_histogram_block_rows * histogram_wg_size;\r\n    let kv_in_offset = wid * rs_block_keyvals + lid;\r\n    for (var i = 0u; i < rs_histogram_block_rows; i++) {\r\n        let pos = kv_in_offset + i * histogram_wg_size;\r\n        kv[i] = keys[pos];\r\n    }\r\n}\r\nfn fill_kv_keys_b(wid: u32, lid: u32) {\r\n    let rs_block_keyvals: u32 = rs_histogram_block_rows * histogram_wg_size;\r\n    let kv_in_offset = wid * rs_block_keyvals + lid;\r\n    for (var i = 0u; i < rs_histogram_block_rows; i++) {\r\n        let pos = kv_in_offset + i * histogram_wg_size;\r\n        kv[i] = keys_b[pos];\r\n    }\r\n}\r\n@compute @workgroup_size({histogram_wg_size})\r\nfn calculate_histogram(@builtin(workgroup_id) wid: vec3<u32>, @builtin(local_invocation_id) lid: vec3<u32>) {\r\n    // efficient loading of multiple values\r\n    fill_kv(wid.x, lid.x);\r\n    \r\n    // Accumulate and store histograms for passes\r\n    histogram_pass(3u, lid.x);\r\n    histogram_pass(2u, lid.x);\r\n    histogram_pass(1u, lid.x);\r\n    histogram_pass(0u, lid.x);\r\n}\r\n\r\n// --------------------------------------------------------------------------------------------------------------\r\n// Prefix sum over histogram\r\n// --------------------------------------------------------------------------------------------------------------\r\nfn prefix_reduce_smem(lid: u32) {\r\n    var offset = 1u;\r\n    for (var d = rs_radix_size >> 1u; d > 0u; d = d >> 1u) { // sum in place tree\r\n        workgroupBarrier();\r\n        if lid < d {\r\n            let ai = offset * (2u * lid + 1u) - 1u;\r\n            let bi = offset * (2u * lid + 2u) - 1u;\r\n            atomicAdd(&smem[bi], atomicLoad(&smem[ai]));\r\n        }\r\n        offset = offset << 1u;\r\n    }\r\n\r\n    if lid == 0u {\r\n        atomicStore(&smem[rs_radix_size - 1u], 0u);\r\n    } // clear the last element\r\n\r\n    for (var d = 1u; d < rs_radix_size; d = d << 1u) {\r\n        offset = offset >> 1u;\r\n        workgroupBarrier();\r\n        if lid < d {\r\n            let ai = offset * (2u * lid + 1u) - 1u;\r\n            let bi = offset * (2u * lid + 2u) - 1u;\r\n\r\n            let t = atomicLoad(&smem[ai]);\r\n            atomicStore(&smem[ai], atomicLoad(&smem[bi]));\r\n            atomicAdd(&smem[bi], t);\r\n        }\r\n    }\r\n}\r\n@compute @workgroup_size({prefix_wg_size})\r\nfn prefix_histogram(@builtin(workgroup_id) wid: vec3<u32>, @builtin(local_invocation_id) lid: vec3<u32>) {\r\n    // the work group  id is the pass, and is inverted in the next line, such that pass 3 is at the first position in the histogram buffer\r\n    let histogram_base = (rs_keyval_size - 1u - wid.x) * rs_radix_size;\r\n    let histogram_offset = histogram_base + lid.x;\r\n    \r\n    // the following coode now corresponds to the prefix calc code in fuchsia/../shaders/prefix.h\r\n    // however the implementation is taken from https://www.eecs.umich.edu/courses/eecs570/hw/parprefix.pdf listing 2 (better overview, nw subgroup arithmetic)\r\n    // this also means that only half the amount of workgroups is spawned (one workgroup calculates for 2 positioons)\r\n    // the smemory is used from the previous section\r\n    atomicStore(&smem[lid.x], atomicLoad(&histograms[histogram_offset]));\r\n    atomicStore(&smem[lid.x + {prefix_wg_size}u], atomicLoad(&histograms[histogram_offset + {prefix_wg_size}u]));\r\n\r\n    prefix_reduce_smem(lid.x);\r\n    workgroupBarrier();\r\n\r\n    atomicStore(&histograms[histogram_offset], atomicLoad(&smem[lid.x]));\r\n    atomicStore(&histograms[histogram_offset + {prefix_wg_size}u], atomicLoad(&smem[lid.x + {prefix_wg_size}u]));\r\n}\r\n\r\n// --------------------------------------------------------------------------------------------------------------\r\n// Scattering the keys\r\n// --------------------------------------------------------------------------------------------------------------\r\n// General note: Only 2 sweeps needed here\r\nvar<workgroup> scatter_smem: array<u32, rs_mem_dwords>; // note: rs_mem_dwords is caclulated in the beginngin of gpu_rs.rs\r\n//            | Dwords                                    | Bytes\r\n//  ----------+-------------------------------------------+--------\r\n//  Lookback  | 256                                       | 1 KB\r\n//  Histogram | 256                                       | 1 KB\r\n//  Prefix    | 4-84                                      | 16-336\r\n//  Reorder   | RS_WORKGROUP_SIZE * RS_SCATTER_BLOCK_ROWS | 2-8 KB\r\nfn partitions_base_offset() -> u32 { return rs_keyval_size * rs_radix_size;}\r\nfn smem_prefix_offset() -> u32 { return rs_radix_size + rs_radix_size;}\r\nfn rs_prefix_sweep_0(idx: u32) -> u32 { return scatter_smem[smem_prefix_offset() + rs_mem_sweep_0_offset + idx];}\r\nfn rs_prefix_sweep_1(idx: u32) -> u32 { return scatter_smem[smem_prefix_offset() + rs_mem_sweep_1_offset + idx];}\r\nfn rs_prefix_sweep_2(idx: u32) -> u32 { return scatter_smem[smem_prefix_offset() + rs_mem_sweep_2_offset + idx];}\r\nfn rs_prefix_load(lid: u32, idx: u32) -> u32 { return scatter_smem[rs_radix_size + lid + idx];}\r\nfn rs_prefix_store(lid: u32, idx: u32, val: u32) { scatter_smem[rs_radix_size + lid + idx] = val;}\r\nfn is_first_local_invocation(lid: u32) -> bool { return lid == 0u;}\r\n\r\nfn histogram_load(digit: u32) -> u32 {\r\n    return atomicLoad(&smem[digit]);\r\n}\r\n\r\nfn histogram_store(digit: u32, count: u32) {\r\n    atomicStore(&smem[digit], count);\r\n}\r\n\r\n\r\nconst rs_partition_mask_status : u32 = 0xC0000000u;\r\nconst rs_partition_mask_count : u32 = 0x3FFFFFFFu;\r\nvar<private> kr : array<u32, rs_scatter_block_rows>;\r\nvar<private> pv : array<u32, rs_scatter_block_rows>;\r\n\r\nfn fill_kv_even(wid: u32, lid: u32) {\r\n    let subgroup_id = lid / histogram_sg_size;\r\n    let subgroup_invoc_id = lid - subgroup_id * histogram_sg_size;\r\n    let subgroup_keyvals = rs_scatter_block_rows * histogram_sg_size;\r\n    let rs_block_keyvals: u32 = rs_histogram_block_rows * histogram_wg_size;\r\n    let kv_in_offset = wid * rs_block_keyvals + subgroup_id * subgroup_keyvals + subgroup_invoc_id;\r\n    for (var i = 0u; i < rs_histogram_block_rows; i++) {\r\n        let pos = kv_in_offset + i * histogram_sg_size;\r\n        kv[i] = keys[pos];\r\n    }\r\n    for (var i = 0u; i < rs_histogram_block_rows; i++) {\r\n        let pos = kv_in_offset + i * histogram_sg_size;\r\n        pv[i] = payload_a[pos];\r\n    }\r\n}\r\n\r\nfn fill_kv_odd(wid: u32, lid: u32) {\r\n    let subgroup_id = lid / histogram_sg_size;\r\n    let subgroup_invoc_id = lid - subgroup_id * histogram_sg_size;\r\n    let subgroup_keyvals = rs_scatter_block_rows * histogram_sg_size;\r\n    let rs_block_keyvals: u32 = rs_histogram_block_rows * histogram_wg_size;\r\n    let kv_in_offset = wid * rs_block_keyvals + subgroup_id * subgroup_keyvals + subgroup_invoc_id;\r\n    for (var i = 0u; i < rs_histogram_block_rows; i++) {\r\n        let pos = kv_in_offset + i * histogram_sg_size;\r\n        kv[i] = keys_b[pos];\r\n    }\r\n    for (var i = 0u; i < rs_histogram_block_rows; i++) {\r\n        let pos = kv_in_offset + i * histogram_sg_size;\r\n        pv[i] = payload_b[pos];\r\n    }\r\n}\r\nfn scatter(pass_: u32, lid: vec3<u32>, gid: vec3<u32>, wid: vec3<u32>, nwg: vec3<u32>, partition_status_invalid: u32, partition_status_reduction: u32, partition_status_prefix: u32) {\r\n    let partition_mask_invalid = partition_status_invalid << 30u;\r\n    let partition_mask_reduction = partition_status_reduction << 30u;\r\n    let partition_mask_prefix = partition_status_prefix << 30u;\r\n    // kv_filling is done in the scatter_even and scatter_odd functions to account for front and backbuffer switch\r\n    // in the reference there is a nulling of the smmem here, was moved to line 251 as smem is used in the code until then\r\n\r\n    // The following implements conceptually the same as the\r\n    // Emulate a \"match\" operation with broadcasts for small subgroup sizes (line 665 ff in scatter.glsl)\r\n    // The difference however is, that instead of using subrgoupBroadcast each thread stores\r\n    // its current number in the smem at lid.x, and then looks up their neighbouring values of the subgroup\r\n    let subgroup_id = lid.x / histogram_sg_size;\r\n    let subgroup_offset = subgroup_id * histogram_sg_size;\r\n    let subgroup_tid = lid.x - subgroup_offset;\r\n    let subgroup_count = {scatter_wg_size}u / histogram_sg_size;\r\n    for (var i = 0u; i < rs_scatter_block_rows; i++) {\r\n        let u_val = bitcast<u32>(kv[i]);\r\n        let digit = extractBits(u_val, pass_ * rs_radix_log2, rs_radix_log2);\r\n        atomicStore(&smem[lid.x], digit);\r\n        var count = 0u;\r\n        var rank = 0u;\r\n        \r\n        for (var j = 0u; j < histogram_sg_size; j++) {\r\n            if atomicLoad(&smem[subgroup_offset + j]) == digit {\r\n                count += 1u;\r\n                if j <= subgroup_tid {\r\n                    rank += 1u;\r\n                }\r\n            }\r\n        }\r\n        \r\n        kr[i] = (count << 16u) | rank;\r\n    }\r\n    \r\n    zero_smem(lid.x);   // now zeroing the smmem as we are now accumulating the histogram there\r\n    workgroupBarrier();\r\n\r\n    // The final histogram is stored in the smem buffer\r\n    for (var i = 0u; i < subgroup_count; i++) {\r\n        if subgroup_id == i {\r\n            for (var j = 0u; j < rs_scatter_block_rows; j++) {\r\n                let v = bitcast<u32>(kv[j]);\r\n                let digit = extractBits(v, pass_ * rs_radix_log2, rs_radix_log2);\r\n                let prev = histogram_load(digit);\r\n                let rank = kr[j] & 0xFFFFu;\r\n                let count = kr[j] >> 16u;\r\n                kr[j] = prev + rank;\r\n\r\n                if rank == count {\r\n                    histogram_store(digit, (prev + count));\r\n                }\r\n                \r\n                // TODO: check if the barrier here is needed\r\n            }            \r\n        }\r\n        workgroupBarrier();\r\n    }\r\n    // kr filling is now done and contains the total offset for each value to be able to \r\n    // move the values into order without having any collisions\r\n    \r\n    // we do not check for single work groups (is currently not assumed to occur very often)\r\n    let partition_offset = lid.x + partitions_base_offset();    // is correct, the partitions pointer does not change\r\n    let partition_base = wid.x * rs_radix_size;\r\n    if wid.x == 0u {\r\n        // special treating for the first workgroup as the data might be read back by later workgroups\r\n        // corresponds to rs_first_prefix_store\r\n        let hist_offset = pass_ * rs_radix_size + lid.x;\r\n        if lid.x < rs_radix_size {\r\n            // let exc = histograms[hist_offset];\r\n            let exc = atomicLoad(&histograms[hist_offset]);\r\n            let red = histogram_load(lid.x);// scatter_smem[rs_keyval_size + lid.x];\r\n            \r\n            scatter_smem[lid.x] = exc;\r\n            \r\n            let inc = exc + red;\r\n\r\n            atomicStore(&histograms[partition_offset], inc | partition_mask_prefix);\r\n        }\r\n    }\r\n    else {\r\n        // standard case for the \"inbetween\" workgroups\r\n        \r\n        // rs_reduction_store, only for inbetween workgroups\r\n        if lid.x < rs_radix_size && wid.x < nwg.x - 1u {\r\n            let red = histogram_load(lid.x);\r\n            atomicStore(&histograms[partition_offset + partition_base], red | partition_mask_reduction);\r\n        }\r\n        \r\n        // rs_loopback_store\r\n        if lid.x < rs_radix_size {\r\n            var partition_base_prev = partition_base - rs_radix_size;\r\n            var exc                 = 0u;\r\n\r\n            // Note: Each workgroup invocation can proceed independently.\r\n            // Subgroups and workgroups do NOT have to coordinate.\r\n            while true {\r\n                //let prev = atomicLoad(&histograms[partition_offset]);// histograms[partition_offset + partition_base_prev];\r\n                let prev = atomicLoad(&histograms[partition_base_prev + partition_offset]);// histograms[partition_offset + partition_base_prev];\r\n                if (prev & rs_partition_mask_status) == partition_mask_invalid {\r\n                    continue;\r\n                }\r\n                exc += prev & rs_partition_mask_count;\r\n                if (prev & rs_partition_mask_status) != partition_mask_prefix {\r\n                    // continue accumulating reduction\r\n                    partition_base_prev -= rs_radix_size;\r\n                    continue;\r\n                }\r\n\r\n                // otherwise save the exclusive scan and atomically transform the\r\n                // reduction into an inclusive prefix status math: reduction + 1 = prefix\r\n                scatter_smem[lid.x] = exc;\r\n\r\n                if wid.x < nwg.x - 1u { // only store when inbetween, skip for last workgrup\r\n                    atomicAdd(&histograms[partition_offset + partition_base], exc | (1u << 30u));\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    // special case for last workgroup is also done in the \"inbetween\" case\r\n    \r\n    // compute exclusive prefix scan of histogram\r\n    // corresponds to rs_prefix\r\n    // TODO make sure that the data is put into smem\r\n    prefix_reduce_smem(lid.x);\r\n    workgroupBarrier();\r\n\r\n    // convert keyval rank to local index, corresponds to rs_rank_to_local\r\n    for (var i = 0u; i < rs_scatter_block_rows; i++) {\r\n        let v = bitcast<u32>(kv[i]);\r\n        let digit = extractBits(v, pass_ * rs_radix_log2, rs_radix_log2);\r\n        let exc   = histogram_load(digit);\r\n        let idx   = exc + kr[i];\r\n        \r\n        kr[i] |= (idx << 16u);\r\n    }\r\n    workgroupBarrier();\r\n    \r\n    // reorder kv[] and kr[], corresponds to rs_reorder\r\n    let smem_reorder_offset = rs_radix_size;\r\n    let smem_base = smem_reorder_offset + lid.x;  // as we are in smem, the radix_size offset is not needed\r\n\r\n    // keyvalues ----------------------------------------------\r\n    // store keyval to sorted location\r\n    for (var j = 0u; j < rs_scatter_block_rows; j++) {\r\n        let smem_idx = smem_reorder_offset + (kr[j] >> 16u) - 1u;\r\n        \r\n        scatter_smem[smem_idx] = bitcast<u32>(kv[j]);\r\n    }\r\n    workgroupBarrier();\r\n\r\n    // Load keyval dword from sorted location\r\n    for (var j = 0u; j < rs_scatter_block_rows; j++) {\r\n        kv[j] = scatter_smem[smem_base + j * {scatter_wg_size}u];\r\n    }\r\n    workgroupBarrier();\r\n    // payload ----------------------------------------------\r\n    // store payload to sorted location\r\n    for (var j = 0u; j < rs_scatter_block_rows; j++) {\r\n        let smem_idx = smem_reorder_offset + (kr[j] >> 16u) - 1u;\r\n        \r\n        scatter_smem[smem_idx] = pv[j];\r\n    }\r\n    workgroupBarrier();\r\n\r\n    // Load payload dword from sorted location\r\n    for (var j = 0u; j < rs_scatter_block_rows; j++) {\r\n        pv[j] = scatter_smem[smem_base + j * {scatter_wg_size}u];\r\n    }\r\n    workgroupBarrier();\r\n    \r\n    // store the digit-index to sorted location\r\n    for (var i = 0u; i < rs_scatter_block_rows; i++) {\r\n        let smem_idx = smem_reorder_offset + (kr[i] >> 16u) - 1u;\r\n        scatter_smem[smem_idx] = kr[i];\r\n    }\r\n    workgroupBarrier();\r\n\r\n    // Load kr[] from sorted location -- we only need the rank\r\n    for (var i = 0u; i < rs_scatter_block_rows; i++) {\r\n        kr[i] = scatter_smem[smem_base + i * {scatter_wg_size}u] & 0xFFFFu;\r\n    }\r\n    \r\n    // convert local index to a global index, corresponds to rs_local_to_global\r\n    for (var i = 0u; i < rs_scatter_block_rows; i++) {\r\n        let v = bitcast<u32>(kv[i]);\r\n        let digit = extractBits(v, pass_ * rs_radix_log2, rs_radix_log2);\r\n        let exc   = scatter_smem[digit];\r\n\r\n        kr[i] += exc - 1u;\r\n    }\r\n    \r\n    // the storing is done in the scatter_even and scatter_odd functions as the front and back buffer changes\r\n}\r\n\r\n@compute @workgroup_size({scatter_wg_size})\r\nfn scatter_even(@builtin(workgroup_id) wid: vec3<u32>, @builtin(local_invocation_id) lid: vec3<u32>, @builtin(global_invocation_id) gid: vec3<u32>, @builtin(num_workgroups) nwg: vec3<u32>) {\r\n    if gid.x == 0u {\r\n        infos.odd_pass = (infos.odd_pass + 1u) % 2u; // for this to work correctly the odd_pass has to start 1\r\n    }\r\n    let cur_pass = infos.even_pass * 2u;\r\n    \r\n    // load from keys, store to keys_b\r\n    fill_kv_even(wid.x, lid.x);\r\n\r\n    let partition_status_invalid = 0u;\r\n    let partition_status_reduction = 1u;\r\n    let partition_status_prefix = 2u;\r\n    scatter(cur_pass, lid, gid, wid, nwg, partition_status_invalid, partition_status_reduction, partition_status_prefix);\r\n\r\n    // store keyvals to their new locations, corresponds to rs_store\r\n    for (var i = 0u; i < rs_scatter_block_rows; i++) {\r\n        keys_b[kr[i]] = kv[i];\r\n    }\r\n    for (var i = 0u; i < rs_scatter_block_rows; i++) {\r\n        payload_b[kr[i]] = pv[i];\r\n    }\r\n}\r\n@compute @workgroup_size({scatter_wg_size})\r\nfn scatter_odd(@builtin(workgroup_id) wid: vec3<u32>, @builtin(local_invocation_id) lid: vec3<u32>, @builtin(global_invocation_id) gid: vec3<u32>, @builtin(num_workgroups) nwg: vec3<u32>) {\r\n    if gid.x == 0u {\r\n        infos.even_pass = (infos.even_pass + 1u) % 2u; // for this to work correctly the even_pass has to start at 0\r\n    }\r\n    let cur_pass = infos.odd_pass * 2u + 1u;\r\n\r\n    // load from keys_b, store to keys\r\n    fill_kv_odd(wid.x, lid.x);\r\n\r\n    let partition_status_invalid = 2u;\r\n    let partition_status_reduction = 3u;\r\n    let partition_status_prefix = 0u;\r\n    scatter(cur_pass, lid, gid, wid, nwg, partition_status_invalid, partition_status_reduction, partition_status_prefix);\r\n\r\n    // store keyvals to their new locations, corresponds to rs_store\r\n    for (var i = 0u; i < rs_scatter_block_rows; i++) {\r\n        keys[kr[i]] = kv[i];\r\n    }\r\n    for (var i = 0u; i < rs_scatter_block_rows; i++) {\r\n        payload_a[kr[i]] = pv[i];\r\n    }\r\n\r\n    // the indirect buffer is reset after scattering via write buffer, see record_scatter_indirect for details\r\n}\r\n`;\n\n","/* The controller can register callbacks for various events on a canvas:\r\n *\r\n * mousemove: function(prevMouse, curMouse, evt)\r\n *     receives both regular mouse events, and single-finger drags (sent as a left-click),\r\n *\r\n * press: function(curMouse, evt)\r\n *     receives mouse click and touch start events\r\n *\r\n * wheel: function(amount)\r\n *     mouse wheel scrolling\r\n */\r\nexport class Controller {\r\n    public mousemove : ((prevMouse : number[], curMouse : number[], evt : MouseEvent) => void) | null;\r\n    public press : ((curMouse : number[], evt : MouseEvent) => void) | null;\r\n    public wheel : ((amount : number) => void) | null;\r\n\r\n    constructor()\r\n    {\r\n        this.mousemove = null;\r\n        this.press = null;\r\n        this.wheel = null;\r\n    }\r\n\r\n    registerForCanvas(canvas : HTMLCanvasElement)\r\n    {\r\n        let prevMouse : number[] | null = null;\r\n        const self = this;\r\n        canvas.addEventListener(\"mousemove\", function(evt : MouseEvent) {\r\n            evt.preventDefault();\r\n            const rect = canvas.getBoundingClientRect();\r\n            const curMouse = [evt.clientX - rect.left, evt.clientY - rect.top];\r\n            if (!prevMouse) {\r\n                prevMouse = [evt.clientX - rect.left, evt.clientY - rect.top];\r\n            } else if (self.mousemove) {\r\n                self.mousemove(prevMouse, curMouse, evt);\r\n            }\r\n            prevMouse = curMouse;\r\n        });\r\n\r\n        canvas.addEventListener(\"mousedown\", function(evt : MouseEvent) {\r\n            evt.preventDefault();\r\n            const rect = canvas.getBoundingClientRect();\r\n            const curMouse = [evt.clientX - rect.left, evt.clientY - rect.top];\r\n            if (self.press) {\r\n                self.press(curMouse, evt);\r\n            }\r\n        });\r\n\r\n        canvas.addEventListener(\"wheel\", function(evt) {\r\n            evt.preventDefault();\r\n            if (self.wheel) {\r\n                self.wheel(-evt.deltaY);\r\n            }\r\n        });\r\n\r\n        canvas.oncontextmenu = function(evt) {\r\n            evt.preventDefault();\r\n        };\r\n    }\r\n}\r\n\r\n","/*\r\n    This file implements a gpu version of radix sort. A good introduction to general purpose radix sort can\r\n    be found here: http://www.codercorner.com/RadixSortRevisited.htm\r\n\r\n    The gpu radix sort implemented here is a re-implementation of the Vulkan radix sort found in the fuchsia repos: https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/graphics/lib/compute/radix_sort/\r\n    Currently only the sorting for 32-bit key-value pairs is implemented\r\n\r\n    All shaders can be found in radix_sort.wgsl\r\n*/\r\nimport {radix_sort} from './wgsl-shaders';\r\n\r\n// IMPORTANT: the following constants have to be synced with the numbers in radix_sort.wgsl\r\n\r\n/// workgroup size of histogram shader\r\nconst HISTOGRAM_WG_SIZE = 256;\r\n\r\n/// one thread operates on 2 prefixes at the same time\r\nconst PREFIX_WG_SIZE = 1 << 7;\r\n\r\n/// scatter compute shader work group size\r\nconst SCATTER_WG_SIZE = 1 << 8;\r\n\r\n/// we sort 8 bits per pass\r\nconst RS_RADIX_LOG2 = 8;\r\n\r\n/// 256 entries into the radix table\r\nconst RS_RADIX_SIZE = 1 << RS_RADIX_LOG2;\r\n\r\n/// number of bytes our keys and values have\r\nconst RS_KEYVAL_SIZE = 32 / RS_RADIX_LOG2;\r\n\r\n/// TODO describe me\r\nconst RS_HISTOGRAM_BLOCK_ROWS = 15;\r\n\r\n/// DO NOT CHANGE, shader assume this!!!\r\nconst RS_SCATTER_BLOCK_ROWS = RS_HISTOGRAM_BLOCK_ROWS;\r\n\r\n/// number of elements scattered by one work group\r\nconst SCATTER_BLOCK_KVS = HISTOGRAM_WG_SIZE * RS_SCATTER_BLOCK_ROWS;\r\n\r\n/// number of elements scattered by one work group\r\nconst HISTO_BLOCK_KVS = HISTOGRAM_WG_SIZE * RS_HISTOGRAM_BLOCK_ROWS;\r\n\r\n/// bytes per value\r\n/// currently only 4 byte values are allowed\r\nconst BYTES_PER_PAYLOAD_ELEM = 4;\r\n\r\n/// number of passed used for sorting\r\n/// we sort 8 bits per pass so 4 passes are required for a 32 bit value\r\nconst NUM_PASSES = BYTES_PER_PAYLOAD_ELEM;\r\n\r\nexport class GPUSorter {\r\n    zeroPipeline: GPUComputePipeline;\r\n    histogramPipeline: GPUComputePipeline;\r\n    prefixPipeline: GPUComputePipeline;\r\n    scatterEvenPipeline: GPUComputePipeline;\r\n    scatterOddPipeline: GPUComputePipeline;\r\n    device: GPUDevice;\r\n    bindGroupLayout: GPUBindGroupLayout;\r\n\r\n    constructor(device: GPUDevice, subgroupSize: number) {\r\n        this.device = device;\r\n        let histogram_sg_size = subgroupSize;\r\n        let rs_sweep_0_size = Math.floor(RS_RADIX_SIZE / histogram_sg_size);\r\n        let rs_sweep_1_size = Math.floor(rs_sweep_0_size / histogram_sg_size);\r\n        // let rs_sweep_2_size = Math.floor(rs_sweep_1_size / histogram_sg_size);\r\n        // let rs_sweep_size = rs_sweep_0_size + rs_sweep_1_size + rs_sweep_2_size;\r\n        // let _rs_smem_phase_1 = RS_RADIX_SIZE + RS_RADIX_SIZE + rs_sweep_size;\r\n        let rs_smem_phase_2 = RS_RADIX_SIZE + RS_SCATTER_BLOCK_ROWS * SCATTER_WG_SIZE;\r\n        // rs_smem_phase_2 will always be larger, so always use phase2\r\n        let rs_mem_dwords = rs_smem_phase_2;\r\n        let rs_mem_sweep_0_offset = 0;\r\n        let rs_mem_sweep_1_offset = rs_mem_sweep_0_offset + rs_sweep_0_size;\r\n        let rs_mem_sweep_2_offset = rs_mem_sweep_1_offset + rs_sweep_1_size;\r\n        console.log(rs_mem_sweep_2_offset);\r\n\r\n        this.bindGroupLayout = this.device.createBindGroupLayout({\r\n            label: \"radix sort bind group layout\",\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: \"storage\" }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: \"storage\" }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: \"storage\" }\r\n                },\r\n                {\r\n                    binding: 3,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: \"storage\" }\r\n                },\r\n                {\r\n                    binding: 4,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: \"storage\" }\r\n                },\r\n                {\r\n                    binding: 5,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: \"storage\" }\r\n                },\r\n            ]\r\n        });\r\n        const pipelineLayout = this.device.createPipelineLayout({\r\n            label: \"radix sort pipeline layout\",\r\n            bindGroupLayouts: [this.bindGroupLayout],\r\n        });\r\n        let shader_code = `\r\n        const histogram_sg_size: u32 = ${histogram_sg_size}u;\r\n        const histogram_wg_size: u32 = ${HISTOGRAM_WG_SIZE}u;\r\n        const rs_radix_log2: u32 = ${RS_RADIX_LOG2}u;\r\n        const rs_radix_size: u32 = ${RS_RADIX_SIZE}u;\r\n        const rs_keyval_size: u32 = ${RS_KEYVAL_SIZE}u;\r\n        const rs_histogram_block_rows: u32 = ${RS_HISTOGRAM_BLOCK_ROWS}u;\r\n        const rs_scatter_block_rows: u32 = ${RS_SCATTER_BLOCK_ROWS}u;\r\n        const rs_mem_dwords: u32 = ${rs_mem_dwords}u;\r\n        const rs_mem_sweep_0_offset: u32 = ${rs_mem_sweep_0_offset}u;\r\n        const rs_mem_sweep_1_offset: u32 = ${rs_mem_sweep_1_offset}u;\r\n        const rs_mem_sweep_2_offset: u32 = ${rs_mem_sweep_2_offset}u;\r\n        ${radix_sort}\r\n        `;\r\n        shader_code = shader_code\r\n            .replace(/{histogram_wg_size}/g, HISTOGRAM_WG_SIZE.toString())\r\n            .replace(/{prefix_wg_size}/g, PREFIX_WG_SIZE.toString())\r\n            .replace(/{scatter_wg_size}/g, SCATTER_WG_SIZE.toString());\r\n        const shader = this.device.createShaderModule({\r\n            label: \"Radix sort shader\",\r\n            code: shader_code,\r\n        });\r\n\r\n        this.zeroPipeline = this.device.createComputePipeline({\r\n            label: \"zero_histograms\",\r\n            layout: pipelineLayout,\r\n            compute: {\r\n                module: shader,\r\n                entryPoint: \"zero_histograms\"\r\n            }\r\n        });\r\n        this.histogramPipeline = this.device.createComputePipeline({\r\n            label: \"calculate_histogram\",\r\n            layout: pipelineLayout,\r\n            compute: {\r\n                module: shader,\r\n                entryPoint: \"calculate_histogram\"\r\n            }\r\n        });\r\n        this.prefixPipeline = this.device.createComputePipeline({\r\n            label: \"prefix_histogram\",\r\n            layout: pipelineLayout,\r\n            compute: {\r\n                module: shader,\r\n                entryPoint: \"prefix_histogram\"\r\n            }\r\n        });\r\n        this.scatterEvenPipeline = this.device.createComputePipeline({\r\n            label: \"scatter_even\",\r\n            layout: pipelineLayout,\r\n            compute: {\r\n                module: shader,\r\n                entryPoint: \"scatter_even\"\r\n            }\r\n        });\r\n        this.scatterOddPipeline = this.device.createComputePipeline({\r\n            label: \"scatter_odd\",\r\n            layout: pipelineLayout,\r\n            compute: {\r\n                module: shader,\r\n                entryPoint: \"scatter_odd\"\r\n            }\r\n        });\r\n    }\r\n\r\n    public createKeyvalBuffers(length: number): [GPUBuffer, GPUBuffer, GPUBuffer, GPUBuffer] {\r\n        // add padding so that our buffer size is a multiple of keys_per_workgroup\r\n        let count_ru_histo = this.keysBufferSize(length) * RS_KEYVAL_SIZE;\r\n        console.log(this.keysBufferSize(length));\r\n        console.log(count_ru_histo);\r\n\r\n        // creating the two needed buffers for sorting\r\n        let keys = this.device.createBuffer({\r\n            label: \"radix sort keys buffer\",\r\n            size: count_ru_histo * BYTES_PER_PAYLOAD_ELEM,\r\n            usage: GPUBufferUsage.STORAGE\r\n                | GPUBufferUsage.COPY_DST\r\n                | GPUBufferUsage.COPY_SRC,\r\n        });\r\n\r\n        // auxiliary buffer for keys\r\n        let keys_aux = this.device.createBuffer({\r\n            label: \"radix sort keys auxiliary buffer\",\r\n            size: count_ru_histo * BYTES_PER_PAYLOAD_ELEM,\r\n            usage: GPUBufferUsage.STORAGE,\r\n        });\r\n\r\n        let payload_size = length * BYTES_PER_PAYLOAD_ELEM; // make sure that we have at least 1 byte of data;\r\n        let payload = this.device.createBuffer({\r\n            label: \"radix sort payload buffer\",\r\n            size: payload_size,\r\n            usage: GPUBufferUsage.STORAGE\r\n                | GPUBufferUsage.COPY_DST\r\n                | GPUBufferUsage.COPY_SRC,\r\n        });\r\n        // auxiliary buffer for payload/values\r\n        let payload_aux = this.device.createBuffer({\r\n            label: \"radix sort payload auxiliary buffer\",\r\n            size: payload_size,\r\n            usage: GPUBufferUsage.STORAGE,\r\n        });\r\n        return [keys, keys_aux, payload, payload_aux];\r\n    }\r\n\r\n    // calculates and allocates a buffer that is sufficient for holding all needed information for\r\n    // sorting. This includes the histograms and the temporary scatter buffer\r\n    // @return: tuple containing [internal memory buffer (should be bound at shader binding 1, count_ru_histo (padded size needed for the keyval buffer)]\r\n    public createInternalMemBuffer(length: number): GPUBuffer {\r\n        // currently only a few different key bits are supported, maybe has to be extended\r\n\r\n        // The \"internal\" memory map looks like this:\r\n        //   +---------------------------------+ <-- 0\r\n        //   | histograms[keyval_size]         |\r\n        //   +---------------------------------+ <-- keyval_size                           * histo_size\r\n        //   | partitions[scatter_blocks_ru-1] |\r\n        //   +---------------------------------+ <-- (keyval_size + scatter_blocks_ru - 1) * histo_size\r\n        //   | workgroup_ids[keyval_size]      |\r\n        //   +---------------------------------+ <-- (keyval_size + scatter_blocks_ru - 1) * histo_size + workgroup_ids_size\r\n\r\n        let s_b_ru = this.scatterBlocksRu(length);\r\n\r\n        let histo_size = RS_RADIX_SIZE * 4;\r\n\r\n        let internal_size = (RS_KEYVAL_SIZE + s_b_ru) * histo_size; // +1 safety\r\n\r\n        let buffer = this.device.createBuffer({\r\n            label: \"Internal radix sort buffer\",\r\n            size: internal_size,\r\n            usage: GPUBufferUsage.STORAGE,\r\n        });\r\n        return buffer;\r\n    }\r\n\r\n    public createSortBuffers(length: number): SortBuffers {\r\n        const [keysA, keysB, payloadA, payloadB] = this.createKeyvalBuffers(length);\r\n        const internalMemBuffer = this.createInternalMemBuffer(length);\r\n\r\n        let uniform_infos = {\r\n            num_keys: length,\r\n            padded_size: this.keysBufferSize(length),\r\n            even_pass: 0,\r\n            odd_pass: 0,\r\n        };\r\n        let uniformBuffer = this.device.createBuffer({\r\n            label: \"radix sort uniform buffer\",\r\n            size: 4 * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n        })\r\n        const uniformData = new Uint32Array([\r\n            uniform_infos.num_keys,\r\n            uniform_infos.padded_size,\r\n            uniform_infos.even_pass,\r\n            uniform_infos.odd_pass\r\n        ]);\r\n        this.device.queue.writeBuffer(uniformBuffer, 0, uniformData);\r\n\r\n        const bindGroup = this.device.createBindGroup({\r\n            label: \"radix sort bind group\",\r\n            layout: this.bindGroupLayout,\r\n            entries: [\r\n                { binding: 0, resource: { buffer: uniformBuffer } },\r\n                { binding: 1, resource: { buffer: internalMemBuffer } },\r\n                { binding: 2, resource: { buffer: keysA } },\r\n                { binding: 3, resource: { buffer: keysB } },\r\n                { binding: 4, resource: { buffer: payloadA } },\r\n                { binding: 5, resource: { buffer: payloadB } },\r\n            ]\r\n        });\r\n\r\n        return new SortBuffers(keysA, keysB, payloadA, payloadB, internalMemBuffer, uniformBuffer, bindGroup, length);\r\n    }\r\n\r\n    \r\n    public recordCalculateHistogram(commandEncoder: GPUCommandEncoder, bindGroup: GPUBindGroup, length: number) {\r\n        // as we only deal with 32 bit float values always 4 passes are conducted\r\n        const histBlocksRu = this.histoBlocksRu(length);\r\n\r\n        const passEncoder = commandEncoder.beginComputePass({label: \"zeroing histogram\"});\r\n        passEncoder.setPipeline(this.zeroPipeline);\r\n        passEncoder.setBindGroup(0, bindGroup);\r\n        passEncoder.dispatchWorkgroups(histBlocksRu, 1, 1);\r\n        passEncoder.end();\r\n\r\n        const passEncoder2 = commandEncoder.beginComputePass({label: \"calculate histogram\"});\r\n        passEncoder2.setPipeline(this.histogramPipeline);\r\n        passEncoder2.setBindGroup(0, bindGroup);\r\n        passEncoder2.dispatchWorkgroups(histBlocksRu, 1, 1);\r\n        passEncoder2.end();\r\n    }\r\n\r\n    // There does not exist an indirect histogram dispatch as the number of prefixes is determined by the amount of passes\r\n    public recordPrefixHistogram(commandEncoder: GPUCommandEncoder, bindGroup: GPUBindGroup) {\r\n        const passEncoder = commandEncoder.beginComputePass({label: \"prefix histogram\"});\r\n        passEncoder.setPipeline(this.prefixPipeline);\r\n        passEncoder.setBindGroup(0, bindGroup);\r\n        passEncoder.dispatchWorkgroups(NUM_PASSES, 1, 1);\r\n        passEncoder.end();\r\n    }\r\n\r\n    public recordScatterKeys(commandEncoder: GPUCommandEncoder, bindGroup: GPUBindGroup, length: number) {\r\n        const scatterBlocksRu = this.scatterBlocksRu(length);\r\n\r\n        const passEncoder = commandEncoder.beginComputePass({label: \"Scatter keyvals\"});\r\n        passEncoder.setBindGroup(0, bindGroup);\r\n\r\n        passEncoder.setPipeline(this.scatterEvenPipeline);\r\n        passEncoder.dispatchWorkgroups(scatterBlocksRu, 1, 1);\r\n\r\n        passEncoder.setPipeline(this.scatterOddPipeline);\r\n        passEncoder.dispatchWorkgroups(scatterBlocksRu, 1, 1);\r\n\r\n        passEncoder.setPipeline(this.scatterEvenPipeline);\r\n        passEncoder.dispatchWorkgroups(scatterBlocksRu, 1, 1);\r\n\r\n        passEncoder.setPipeline(this.scatterOddPipeline);\r\n        passEncoder.dispatchWorkgroups(scatterBlocksRu, 1, 1);\r\n\r\n        passEncoder.end();\r\n    }\r\n\r\n    /// Writes sort commands to command encoder.\r\n    /// If sort_first_n is not none one the first n elements are sorted\r\n    /// otherwise everything is sorted.\r\n    ///\r\n    /// **IMPORTANT**: if less than the whole buffer is sorted the rest of the keys buffer will be be corrupted\r\n    public sort(commandEncoder: GPUCommandEncoder, queue: GPUQueue, sortBuffers: SortBuffers, sortFirstN?: number) {\r\n        const numElements = sortFirstN ?? sortBuffers.length;\r\n\r\n        // Update state buffer\r\n        queue.writeBuffer(sortBuffers.uniformBuffer, 0, new Uint32Array([numElements]));\r\n\r\n        this.recordCalculateHistogram(commandEncoder, sortBuffers.bindGroup, numElements);\r\n        this.recordPrefixHistogram(commandEncoder, sortBuffers.bindGroup);\r\n        this.recordScatterKeys(commandEncoder, sortBuffers.bindGroup, numElements);\r\n    }\r\n\r\n    public scatterBlocksRu(n: number): number {\r\n        return Math.ceil(n / SCATTER_BLOCK_KVS);\r\n    }\r\n\r\n    public histoBlocksRu(n: number): number {\r\n        return Math.ceil((this.scatterBlocksRu(n) * SCATTER_BLOCK_KVS) / HISTO_BLOCK_KVS);\r\n    }\r\n\r\n    public keysBufferSize(n: number): number {\r\n        return this.histoBlocksRu(n) * HISTO_BLOCK_KVS;\r\n    }\r\n}\r\n\r\nclass SortBuffers {\r\n    constructor(\r\n        public keysA: GPUBuffer,\r\n        public keysB: GPUBuffer,\r\n        public payloadA: GPUBuffer,\r\n        public payloadB: GPUBuffer,\r\n        public internalMemBuffer: GPUBuffer,\r\n        public uniformBuffer: GPUBuffer,\r\n        public bindGroup: GPUBindGroup,\r\n        public length: number\r\n    ) {}\r\n\r\n    get keys(): GPUBuffer {\r\n        return this.keysA;\r\n    }\r\n\r\n    get values(): GPUBuffer {\r\n        return this.payloadA;\r\n    }\r\n\r\n    keysValidSize(): number {\r\n        return this.length * RS_KEYVAL_SIZE;\r\n    }\r\n\r\n    destroy() {\r\n        this.keysA.destroy();\r\n        this.keysB.destroy();\r\n        this.payloadA.destroy();\r\n        this.payloadB.destroy();\r\n        this.internalMemBuffer.destroy();\r\n        this.uniformBuffer.destroy();\r\n    }\r\n}","import {apply_forces} from './wgsl-shaders';\r\nimport {create_targetlist} from './wgsl-shaders';\r\nimport {create_sourcelist} from './wgsl-shaders';\r\nimport {compute_forcesBH} from './wgsl-shaders';\r\nimport {compute_attractive_new} from './wgsl-shaders';\r\nimport {morton_codes} from './wgsl-shaders';\r\nimport {create_tree} from './wgsl-shaders';\r\nimport { GPUSorter } from './sort';\r\n\r\nexport class ForceDirected {\r\n    public sorter: GPUSorter;\r\n    public paramsBuffer: GPUBuffer;\r\n    public nodeDataBuffer: GPUBuffer;\r\n    public edgeDataBuffer: GPUBuffer;\r\n    public forceDataBuffer: GPUBuffer;\r\n    public coolingFactor: number = 0.985;\r\n    public device: GPUDevice;\r\n    public createTreePipeline: GPUComputePipeline;\r\n    public createSourceListPipeline: GPUComputePipeline;\r\n    public createTargetListPipeline: GPUComputePipeline;\r\n    public computeAttractivePipeline: GPUComputePipeline;\r\n    public computeForcesBHPipeline: GPUComputePipeline;\r\n    public applyForcesPipeline: GPUComputePipeline;\r\n    public iterationCount: number = 1;\r\n    public mortonCodePipeline: GPUComputePipeline;\r\n    public mortonCodeBuffer: GPUBuffer;\r\n    public theta: number = 0.8;\r\n    public l: number = 0.01;\r\n    public stopForce: boolean = false;\r\n    clusterSize: number;\r\n    public nodeLength: number;\r\n    public edgeLength: number;\r\n    sourceEdgeDataBuffer: GPUBuffer;\r\n    targetEdgeDataBuffer: GPUBuffer;\r\n\r\n    constructor(device: GPUDevice) {\r\n        this.device = device;\r\n        this.sorter = new GPUSorter(this.device, 32);\r\n        this.clusterSize = 4;\r\n        this.nodeLength = 0;\r\n        this.edgeLength = 0;\r\n\r\n        this.nodeDataBuffer = this.device.createBuffer({\r\n            size: 16,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n        });\r\n\r\n        this.mortonCodeBuffer = this.device.createBuffer({\r\n            size: 16,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n        });\r\n\r\n        this.edgeDataBuffer = this.device.createBuffer({\r\n            size: 16,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n        });\r\n\r\n        this.sourceEdgeDataBuffer = this.device.createBuffer({\r\n            size: 16,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n        });\r\n\r\n        this.targetEdgeDataBuffer = this.device.createBuffer({\r\n            size: 16,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n        });\r\n\r\n        this.forceDataBuffer = this.device.createBuffer({\r\n            size: 16,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n        });\r\n\r\n        this.createTreePipeline = device.createComputePipeline({\r\n            layout: 'auto',\r\n            compute: {\r\n                module: device.createShaderModule({\r\n                    code: create_tree.replace(/CHANGEME/g, this.clusterSize.toString())\r\n                }),\r\n                entryPoint: \"main\",\r\n            },\r\n        });\r\n\r\n        this.mortonCodePipeline = device.createComputePipeline({\r\n            layout: 'auto',\r\n            compute: {\r\n                module: device.createShaderModule({\r\n                    code: morton_codes.replace(/CHANGEME/g, this.clusterSize.toString())\r\n                }),\r\n                entryPoint: \"main\",\r\n            }\r\n        });\r\n\r\n        this.createSourceListPipeline = device.createComputePipeline({\r\n            layout: 'auto',\r\n            compute: {\r\n                module: device.createShaderModule({\r\n                    code: create_sourcelist\r\n                }),\r\n                entryPoint: \"main\",\r\n            },\r\n        });\r\n\r\n        this.createTargetListPipeline = device.createComputePipeline({\r\n            layout: 'auto',\r\n            compute: {\r\n                module: device.createShaderModule({\r\n                    code: create_targetlist\r\n                }),\r\n                entryPoint: \"main\",\r\n            },\r\n        });\r\n\r\n        this.computeAttractivePipeline = device.createComputePipeline({\r\n            layout: 'auto',\r\n            compute: {\r\n                module: device.createShaderModule({\r\n                    code: compute_attractive_new\r\n                }),\r\n                entryPoint: \"main\",\r\n            },\r\n        });\r\n\r\n        this.computeForcesBHPipeline = device.createComputePipeline({\r\n            layout: 'auto',\r\n            compute: {\r\n                module: device.createShaderModule({\r\n                    code: compute_forcesBH.replace(/CHANGEME/g, this.clusterSize.toString()),\r\n                }),\r\n                entryPoint: \"main\",\r\n            },\r\n        });\r\n\r\n        this.applyForcesPipeline = device.createComputePipeline({\r\n            layout: 'auto',\r\n            compute: {\r\n                module: device.createShaderModule({\r\n                    code: apply_forces,\r\n                }),\r\n                entryPoint: \"main\",\r\n            },\r\n        });\r\n\r\n        // Create a buffer to store the params, output, and min/max\r\n        this.paramsBuffer = device.createBuffer({\r\n            size: 4 * 4,\r\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n        });\r\n    }\r\n\r\n    stopForces() {\r\n        this.stopForce = true;\r\n    }\r\n\r\n    formatToD3Format(positionList: number[], edgeList: number[], nLength: number, eLength: number) {\r\n        const nodeArray = new Array(nLength);\r\n        const edgeArray = new Array(eLength / 2);\r\n\r\n        for (let i = 0; i < 4 * nLength; i = i + 4) {\r\n            nodeArray[i / 4] = {\r\n                index: i / 4,\r\n                name: (i / 4).toString(),\r\n                x: positionList[i + 1],\r\n                y: positionList[i + 2]\r\n            };\r\n        }\r\n\r\n        for (let i = 0; i < eLength; i = i + 2) {\r\n            let sourceIndex = edgeList[i];\r\n            let targetIndex = edgeList[i + 1];\r\n\r\n            edgeArray[i / 2] = {};\r\n\r\n            edgeArray[i / 2].index = i / 2;\r\n            edgeArray[i / 2].source = {};\r\n            edgeArray[i / 2].source.index = sourceIndex;\r\n            edgeArray[i / 2].source.name = sourceIndex.toString();\r\n            edgeArray[i / 2].source.x = nodeArray[sourceIndex].x;\r\n            edgeArray[i / 2].source.y = nodeArray[sourceIndex].y;\r\n\r\n            edgeArray[i / 2].target = {};\r\n            edgeArray[i / 2].target.index = targetIndex;\r\n            edgeArray[i / 2].target.name = targetIndex.toString();\r\n            edgeArray[i / 2].target.x = nodeArray[targetIndex].x;\r\n            edgeArray[i / 2].target.y = nodeArray[targetIndex].y;\r\n        }\r\n\r\n        return { nodeArray, edgeArray }\r\n    }\r\n\r\n    setNodeEdgeData(nodes : number[], edges : number[]) {\r\n        this.nodeLength = nodes.length / 4;\r\n        this.edgeLength = edges.length;\r\n        this.nodeDataBuffer = this.device.createBuffer({\r\n            size: nodes.length * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n            mappedAtCreation: true,\r\n        });\r\n        new Float32Array(this.nodeDataBuffer.getMappedRange()).set(nodes);\r\n        this.nodeDataBuffer.unmap();\r\n        this.mortonCodeBuffer = this.device.createBuffer({\r\n            size: nodes.length,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n        });\r\n        this.edgeDataBuffer = this.device.createBuffer({\r\n            size: edges.length * 4,\r\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\r\n            mappedAtCreation: true\r\n        });\r\n        new Uint32Array(this.edgeDataBuffer.getMappedRange()).set(edges);\r\n        this.edgeDataBuffer.unmap();\r\n        type edge = {\r\n            source: number,\r\n            target: number\r\n        }\r\n        const edges2: Array<edge> = [];\r\n        for (let i = 0; i < edges.length; i += 2) {\r\n            edges2.push({source: edges[i], target: edges[i + 1]});\r\n        }\r\n        const sortedBySource = edges2\r\n            .sort((a, b) => a.source - b.source)\r\n            .flatMap(edge => [edge.source, edge.target]);\r\n        const sortedByTarget = edges2\r\n            .slice()\r\n            .sort((a, b) => a.target - b.target)\r\n            .flatMap(edge => [edge.source, edge.target]);\r\n        console.log(sortedBySource);\r\n        console.log(sortedByTarget);\r\n        this.sourceEdgeDataBuffer = this.device.createBuffer({\r\n            size: sortedBySource.length * 4,\r\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\r\n            mappedAtCreation: true\r\n        });\r\n        new Uint32Array(this.sourceEdgeDataBuffer.getMappedRange()).set(sortedBySource);\r\n        this.sourceEdgeDataBuffer.unmap();\r\n        this.targetEdgeDataBuffer = this.device.createBuffer({\r\n            size: sortedByTarget.length * 4,\r\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\r\n            mappedAtCreation: true\r\n        });\r\n        new Uint32Array(this.targetEdgeDataBuffer.getMappedRange()).set(sortedByTarget);\r\n        this.targetEdgeDataBuffer.unmap();\r\n    }\r\n\r\n    async runForces(\r\n        coolingFactor = this.coolingFactor, l = this.l,\r\n        theta: number = this.theta, iterationCount = this.iterationCount\r\n    ) {\r\n        this.stopForce = false;\r\n        if (this.nodeLength === 0 || this.edgeLength === 0 || this.nodeDataBuffer === null || this.edgeDataBuffer === null) {\r\n            console.log(\"No data to run\");\r\n            return;\r\n        }\r\n        this.l = l;\r\n        this.theta = theta;\r\n        this.coolingFactor = coolingFactor;\r\n        this.iterationCount = iterationCount;\r\n        const rangeBuffer = this.device.createBuffer({\r\n            size: 4 * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\r\n        });\r\n        const bounding = this.device.createBuffer({\r\n            size: 4 * 4,\r\n            usage: GPUBufferUsage.COPY_SRC,\r\n            mappedAtCreation: true,\r\n        });\r\n\r\n        let mapping = bounding.getMappedRange();\r\n        new Int32Array(mapping).set([0, 1000, 0, 1000]);\r\n        bounding.unmap();\r\n        const bounding2 = this.device.createBuffer({\r\n            size: 4 * 4,\r\n            usage: GPUBufferUsage.COPY_SRC,\r\n            mappedAtCreation: true,\r\n        });\r\n\r\n        let mapping2 = bounding2.getMappedRange();\r\n        new Int32Array(mapping2).set([1000, -1000, 1000, -1000]);\r\n        bounding2.unmap();\r\n        // this.coolingFactor = 2.0;\r\n        let commandEncoder = this.device.createCommandEncoder();\r\n        commandEncoder.copyBufferToBuffer(bounding, 0, rangeBuffer, 0, 4 * 4);\r\n        this.device.queue.submit([commandEncoder.finish()]);\r\n    \r\n        const sortBuffers = this.sorter.createSortBuffers(this.nodeLength);\r\n\r\n        // Set up params (node length, edge length) for creating adjacency matrix\r\n        const uploadBuffer = this.device.createBuffer({\r\n            size: 4 * 4,\r\n            usage: GPUBufferUsage.COPY_SRC,\r\n            mappedAtCreation: true,\r\n        });\r\n        mapping = uploadBuffer.getMappedRange();\r\n        new Uint32Array(mapping).set([this.nodeLength, this.edgeLength]);\r\n        new Float32Array(mapping).set([this.coolingFactor, l], 2);\r\n        uploadBuffer.unmap();\r\n\r\n        commandEncoder = this.device.createCommandEncoder();\r\n        commandEncoder.copyBufferToBuffer(uploadBuffer, 0, this.paramsBuffer, 0, 4 * 4);\r\n\r\n        this.device.queue.submit([commandEncoder.finish()]);\r\n\r\n        // Create a buffer to store the params, output, and min/max\r\n        const treeInfoBuffer = this.device.createBuffer({\r\n            size: 4 * 4,\r\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n        });\r\n        this.device.queue.writeBuffer(\r\n            treeInfoBuffer,\r\n            8,\r\n            new Float32Array([this.theta]),\r\n            0,\r\n            1\r\n        );\r\n\r\n        this.forceDataBuffer = this.device.createBuffer({\r\n            size: this.nodeLength * 2 * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\r\n        });\r\n        const sourceListBuffer = this.device.createBuffer({\r\n            size: this.edgeLength * 2,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n        });\r\n        const targetListBuffer = this.device.createBuffer({\r\n            size: this.edgeLength * 2,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n        });\r\n        const edgeInfoBuffer = this.device.createBuffer({\r\n            size: this.nodeLength * 4 * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n        });\r\n        const treeBuffer = this.device.createBuffer({\r\n            size: Math.ceil(this.nodeLength * 2.1) * (12 + Math.max(4, this.clusterSize)) * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n        });\r\n\r\n        const createSourceListBindGroup = this.device.createBindGroup({\r\n            layout: this.createSourceListPipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: {\r\n                        buffer: this.sourceEdgeDataBuffer!,\r\n                    }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    resource: {\r\n                        buffer: edgeInfoBuffer,\r\n                    }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    resource: {\r\n                        buffer: sourceListBuffer,\r\n                    },\r\n                },\r\n                {\r\n                    binding: 3,\r\n                    resource: {\r\n                        buffer: this.paramsBuffer\r\n                    }\r\n                }\r\n            ]\r\n        });\r\n\r\n        const createTargetListBindGroup = this.device.createBindGroup({\r\n            layout: this.createTargetListPipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: {\r\n                        buffer: this.targetEdgeDataBuffer,\r\n                    }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    resource: {\r\n                        buffer: edgeInfoBuffer,\r\n                    }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    resource: {\r\n                        buffer: targetListBuffer,\r\n                    },\r\n                },\r\n                {\r\n                    binding: 3,\r\n                    resource: {\r\n                        buffer: this.paramsBuffer\r\n                    }\r\n                }\r\n            ]\r\n        })\r\n        this.device.queue.submit([commandEncoder.finish()]);\r\n        commandEncoder = this.device.createCommandEncoder();\r\n        // Run create source and target lists pass\r\n        const computePassEncoder = commandEncoder.beginComputePass();\r\n        computePassEncoder.setBindGroup(0, createSourceListBindGroup);\r\n        computePassEncoder.setPipeline(this.createSourceListPipeline);\r\n        computePassEncoder.dispatchWorkgroups(1, 1, 1);\r\n        computePassEncoder.setBindGroup(0, createTargetListBindGroup);\r\n        computePassEncoder.setPipeline(this.createTargetListPipeline);\r\n        computePassEncoder.dispatchWorkgroups(1, 1, 1);\r\n        computePassEncoder.end();\r\n        const gpuReadBuffer = this.device.createBuffer({\r\n            size: this.nodeLength * 4 * 4,\r\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\r\n        });\r\n        commandEncoder.copyBufferToBuffer(\r\n            edgeInfoBuffer /* source buffer */,\r\n            0 /* source offset */,\r\n            gpuReadBuffer /* destination buffer */,\r\n            0 /* destination offset */,\r\n            this.nodeLength * 4 * 4 /* size */\r\n        );\r\n        this.device.queue.submit([commandEncoder.finish()]);\r\n        // await this.device.queue.onSubmittedWorkDone();\r\n        // await gpuReadBuffer.mapAsync(GPUMapMode.READ);\r\n        // const arrayBuffer = gpuReadBuffer.getMappedRange();\r\n        // const list = new Uint32Array(arrayBuffer);\r\n        // console.log(list);\r\n        // return;\r\n\r\n        // const iterationTimes: Array<number> = [];\r\n        const applyBindGroup = this.device.createBindGroup({\r\n            layout: this.applyForcesPipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: {\r\n                        buffer: this.nodeDataBuffer,\r\n                    },\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    resource: {\r\n                        buffer: this.forceDataBuffer,\r\n                    }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    resource: {\r\n                        buffer: this.paramsBuffer\r\n                    }\r\n                },\r\n                {\r\n                    binding: 3,\r\n                    resource: {\r\n                        buffer: rangeBuffer\r\n                    }\r\n                }\r\n            ],\r\n        });\r\n\r\n        const createTreeBindGroup = this.device.createBindGroup({\r\n            layout: this.createTreePipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                // Sort values buffer filled with indices\r\n                {\r\n                    binding: 0,\r\n                    resource: {\r\n                        buffer: sortBuffers.values,\r\n                    }\r\n                },  \r\n                {\r\n                    binding: 1,\r\n                    resource: {\r\n                        buffer: this.paramsBuffer,\r\n                    }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    resource: {\r\n                        buffer: treeInfoBuffer,\r\n                    }\r\n                },\r\n                {\r\n                    binding: 3,\r\n                    resource: {\r\n                        buffer: rangeBuffer,\r\n                    }\r\n                },\r\n                {\r\n                    binding: 4,\r\n                    resource: {\r\n                        buffer: treeBuffer,\r\n                    }\r\n                },\r\n            ]\r\n        });\r\n        const mortonCodeBindGroup = this.device.createBindGroup({\r\n            layout: this.mortonCodePipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: {\r\n                        buffer: this.nodeDataBuffer,\r\n                    }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    resource: {\r\n                        buffer: this.mortonCodeBuffer,\r\n                    }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    resource: {\r\n                        buffer: this.paramsBuffer,\r\n                    }\r\n                },\r\n                {\r\n                    binding: 3,\r\n                    resource: {\r\n                        buffer: rangeBuffer,\r\n                    }\r\n                },\r\n                // Sort values buffer filled with mor\r\n                {\r\n                    binding: 4,\r\n                    resource: {\r\n                        buffer: sortBuffers.values,\r\n                    }\r\n                },\r\n                {\r\n                    binding: 5,\r\n                    resource: {\r\n                        buffer: treeBuffer,\r\n                    }\r\n                },\r\n            ]\r\n        });\r\n        // const batchBuffer = this.device.createBuffer({\r\n        //     size: 4,\r\n        //     usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM\r\n        // });\r\n        let positionReadBuffer = this.device.createBuffer({\r\n            size: this.nodeLength * 4 * 4,\r\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\r\n        });\r\n        let numIterations = 0;\r\n        var totalTime = 0;\r\n        var totalTree = 0;\r\n        var start, end;\r\n        const debug = false;\r\n        var totalStart = 0;\r\n        while (numIterations < iterationCount && this.coolingFactor > 0.0001) {\r\n            if (numIterations == 1) {\r\n                totalStart = performance.now();\r\n            }\r\n            const frameStart = performance.now();\r\n            numIterations++;\r\n            // Set up params (node length, edge length)\r\n            const upload = this.device.createBuffer({\r\n                size: 4 * 4,\r\n                usage: GPUBufferUsage.COPY_SRC,\r\n                mappedAtCreation: true,\r\n            });\r\n            const mapping = upload.getMappedRange();\r\n            new Uint32Array(mapping).set([this.nodeLength, this.edgeLength]);\r\n            new Float32Array(mapping).set([this.coolingFactor, l], 2);\r\n            upload.unmap();\r\n            //this.device.createQuerySet({})\r\n            let commandEncoder = this.device.createCommandEncoder();\r\n            //commandEncoder.writeTimestamp();\r\n            commandEncoder.copyBufferToBuffer(upload, 0, this.paramsBuffer, 0, 4 * 4);\r\n            this.device.queue.submit([commandEncoder.finish()]);\r\n            if (debug) {await this.device.queue.onSubmittedWorkDone();}\r\n            start = performance.now();\r\n            commandEncoder = this.device.createCommandEncoder();\r\n            let computePassEncoder = commandEncoder.beginComputePass();\r\n            computePassEncoder.setBindGroup(0, mortonCodeBindGroup);\r\n            computePassEncoder.setPipeline(this.mortonCodePipeline);\r\n            computePassEncoder.dispatchWorkgroups(Math.ceil(this.nodeLength / 128), 1, 1);\r\n            computePassEncoder.end();\r\n            commandEncoder.copyBufferToBuffer(this.mortonCodeBuffer, 0, sortBuffers.keys, 0, this.mortonCodeBuffer.size);\r\n            this.device.queue.submit([commandEncoder.finish()]);\r\n            if (debug) {await this.device.queue.onSubmittedWorkDone();}\r\n            end = performance.now();\r\n            console.log(`Morton codes took ${end - start}ms`)\r\n            {\r\n                // var dbgBuffer = this.device.createBuffer({\r\n                //     size: this.mortonCodeBuffer.size,\r\n                //     usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\r\n                // });\r\n\r\n                // commandEncoder = this.device.createCommandEncoder();\r\n                // commandEncoder.copyBufferToBuffer(this.mortonCodeBuffer, 0, dbgBuffer, 0, dbgBuffer.size);\r\n                // this.device.queue.submit([commandEncoder.finish()]);\r\n                // await this.device.queue.onSubmittedWorkDone();\r\n\r\n                // await dbgBuffer.mapAsync(GPUMapMode.READ);\r\n\r\n                // var debugValsf = new Float32Array(dbgBuffer.getMappedRange());\r\n                // console.log(debugValsf);\r\n\r\n                var dbgBufferu = this.device.createBuffer({\r\n                    size: this.mortonCodeBuffer.size,\r\n                    usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\r\n                });\r\n\r\n                commandEncoder = this.device.createCommandEncoder();\r\n                commandEncoder.copyBufferToBuffer(this.mortonCodeBuffer, 0, dbgBufferu, 0, dbgBufferu.size);\r\n                this.device.queue.submit([commandEncoder.finish()]);\r\n                await this.device.queue.onSubmittedWorkDone();\r\n\r\n                await dbgBufferu.mapAsync(GPUMapMode.READ);\r\n\r\n                var debugValsu = new Uint32Array(dbgBufferu.getMappedRange());\r\n                console.log(debugValsu);\r\n            }\r\n\r\n            start = performance.now();\r\n            const sortEncoder = this.device.createCommandEncoder();\r\n            this.sorter.sort(sortEncoder, this.device.queue, sortBuffers);\r\n            this.device.queue.submit([sortEncoder.finish()]);\r\n            if (debug) {await this.device.queue.onSubmittedWorkDone();}\r\n            end = performance.now();\r\n            console.log(`Sort took ${end - start} ms`);\r\n            {\r\n                var dbgBuffer = this.device.createBuffer({\r\n                    size: sortBuffers.keys.size,\r\n                    usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\r\n                });\r\n\r\n                commandEncoder = this.device.createCommandEncoder();\r\n                commandEncoder.copyBufferToBuffer(sortBuffers.keys, 0, dbgBuffer, 0, dbgBuffer.size);\r\n                this.device.queue.submit([commandEncoder.finish()]);\r\n                await this.device.queue.onSubmittedWorkDone();\r\n\r\n                await dbgBuffer.mapAsync(GPUMapMode.READ);\r\n\r\n                var debugValsu = new Uint32Array(dbgBuffer.getMappedRange());\r\n                console.log(debugValsu);\r\n            }\r\n            let startTot = performance.now();\r\n            var maxIndex = this.nodeLength;\r\n            commandEncoder = this.device.createCommandEncoder();\r\n            for (var i = 0; i < Math.log(this.nodeLength) / Math.log(this.clusterSize); i++) {\r\n                // start = performance.now();\r\n                this.device.queue.writeBuffer(\r\n                    treeInfoBuffer,\r\n                    0,\r\n                    new Uint32Array([i]),\r\n                    0,\r\n                    1\r\n                );\r\n                commandEncoder = this.device.createCommandEncoder();\r\n                computePassEncoder = commandEncoder.beginComputePass();\r\n                computePassEncoder.setBindGroup(0, createTreeBindGroup);\r\n                computePassEncoder.setPipeline(this.createTreePipeline);\r\n                computePassEncoder.dispatchWorkgroups(Math.ceil(this.nodeLength / (128 * this.clusterSize**(i+1))), 1, 1);\r\n                computePassEncoder.end();\r\n                this.device.queue.submit([commandEncoder.finish()]);\r\n                // await this.device.queue.onSubmittedWorkDone();\r\n                maxIndex += Math.ceil(this.nodeLength / this.clusterSize**(i+1))\r\n                // end = performance.now();\r\n                // console.log(`Create Tree iter ${i} took ${end - start}ms`)\r\n            }\r\n            this.device.queue.writeBuffer(\r\n                treeInfoBuffer,\r\n                4,\r\n                new Uint32Array([maxIndex]),\r\n                0,\r\n                1\r\n            );\r\n            this.device.queue.submit([commandEncoder.finish()]);\r\n            if (debug) {await this.device.queue.onSubmittedWorkDone();}\r\n            let endTot = performance.now();\r\n            totalTree += endTot - startTot;\r\n            console.log(`Create Tree took ${endTot - startTot}ms`)\r\n            {\r\n                // console.log(this.nodeLength);\r\n                // var dbgBuffer = this.device.createBuffer({\r\n                //     size: treeBuffer.size,\r\n                //     usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\r\n                // });\r\n\r\n                // commandEncoder = this.device.createCommandEncoder();\r\n                // commandEncoder.copyBufferToBuffer(treeBuffer, 0, dbgBuffer, 0, dbgBuffer.size);\r\n                // this.device.queue.submit([commandEncoder.finish()]);\r\n                // await this.device.queue.onSubmittedWorkDone();\r\n\r\n                // await dbgBuffer.mapAsync(GPUMapMode.READ);\r\n\r\n                // var debugValsf = new Float32Array(dbgBuffer.getMappedRange());\r\n                // console.log(debugValsf);\r\n                // console.log(maxIndex * 16);\r\n                // var sum_size = 0;\r\n                // for (var tt = this.nodeLength * 16 + 16; tt < maxIndex * 16 + 16; tt += 16) {\r\n                //     sum_size += debugValsf[tt + 2];\r\n                // }\r\n                // console.log(sum_size / (maxIndex - this.nodeLength));\r\n                // total_sumsize += sum_size / (maxIndex - this.nodeLength);\r\n                // dbgBuffer.destroy();\r\n                // var dbgBufferu = this.device.createBuffer({\r\n                //     size: treeBuffer.size,\r\n                //     usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\r\n                // });\r\n\r\n                // commandEncoder = this.device.createCommandEncoder();\r\n                // commandEncoder.copyBufferToBuffer(treeBuffer, 0, dbgBufferu, 0, dbgBuffer.size);\r\n                // this.device.queue.submit([commandEncoder.finish()]);\r\n                // await this.device.queue.onSubmittedWorkDone();\r\n\r\n                // await dbgBufferu.mapAsync(GPUMapMode.READ);\r\n\r\n                // var debugValsu = new Uint32Array(dbgBufferu.getMappedRange());\r\n                // console.log(debugValsu);\r\n            }\r\n\r\n            commandEncoder = this.device.createCommandEncoder();\r\n            // const commandEncoder = this.device.createCommandEncoder();\r\n            // start = performance.now();\r\n            // Create BH bindgroup\r\n            const computeForcesBHBindGroup = this.device.createBindGroup({\r\n                layout: this.computeForcesBHPipeline.getBindGroupLayout(0),\r\n                entries: [\r\n                    {\r\n                        binding: 0,\r\n                        resource: {\r\n                            buffer: this.nodeDataBuffer,\r\n                        },\r\n                    },\r\n                    {\r\n                        binding: 1,\r\n                        resource: {\r\n                            buffer: this.forceDataBuffer,\r\n                        }\r\n                    },\r\n                    {\r\n                        binding: 2,\r\n                        resource: {\r\n                            buffer: this.paramsBuffer,\r\n                        },\r\n                    },\r\n                    {\r\n                        binding: 3,\r\n                        resource: {\r\n                            buffer: treeInfoBuffer\r\n                        }\r\n                    },\r\n                    {\r\n                        binding: 4,\r\n                        resource: {\r\n                            buffer: treeBuffer\r\n                        }\r\n                    }\r\n                ],\r\n            });\r\n\r\n            // Run attract forces pass\r\n            const attractBindGroup = this.device.createBindGroup({\r\n                layout: this.computeAttractivePipeline.getBindGroupLayout(0),\r\n                entries: [\r\n                    {\r\n                        binding: 0,\r\n                        resource: {\r\n                            buffer: edgeInfoBuffer,\r\n                        },\r\n                    },\r\n                    {\r\n                        binding: 1,\r\n                        resource: {\r\n                            buffer: sourceListBuffer,\r\n                        },\r\n                    },\r\n                    {\r\n                        binding: 2,\r\n                        resource: {\r\n                            buffer: targetListBuffer,\r\n                        },\r\n                    },\r\n                    {\r\n                        binding: 3,\r\n                        resource: {\r\n                            buffer: this.forceDataBuffer,\r\n                        }\r\n                    },\r\n                    {\r\n                        binding: 4,\r\n                        resource: {\r\n                            buffer: this.nodeDataBuffer,\r\n                        }\r\n                    },\r\n                    {\r\n                        binding: 5,\r\n                        resource: {\r\n                            buffer: this.paramsBuffer,\r\n                        },\r\n                    },\r\n                ],\r\n            });\r\n            if (debug) {await this.device.queue.onSubmittedWorkDone();}\r\n\r\n            // Run attract forces pass\r\n            computePassEncoder = commandEncoder.beginComputePass();\r\n            computePassEncoder.setBindGroup(0, attractBindGroup);\r\n            computePassEncoder.setPipeline(this.computeAttractivePipeline);\r\n            computePassEncoder.dispatchWorkgroups(Math.ceil(this.nodeLength / 128), 1, 1);\r\n            computePassEncoder.end();\r\n\r\n            this.device.queue.submit([commandEncoder.finish()]);\r\n            start = performance.now();\r\n            if (debug) {await this.device.queue.onSubmittedWorkDone();}\r\n            end = performance.now();\r\n            console.log(`attract force time: ${end - start}`)\r\n\r\n            // Run compute forces BH pass\r\n            start = performance.now();\r\n            commandEncoder = this.device.createCommandEncoder();\r\n\r\n            const pass = commandEncoder.beginComputePass();\r\n            pass.setBindGroup(0, computeForcesBHBindGroup);\r\n            pass.setPipeline(this.computeForcesBHPipeline);\r\n            pass.dispatchWorkgroups(Math.ceil(this.nodeLength / 128), 1, 1);\r\n            pass.end();\r\n            this.device.queue.submit([commandEncoder.finish()]);\r\n            if (debug) {await this.device.queue.onSubmittedWorkDone();}\r\n            end = performance.now();\r\n            console.log(`repulse force time: ${end - start}`)\r\n\r\n            {\r\n                // var dbgBuffer = this.device.createBuffer({\r\n                //     size: treeBuffer.size,\r\n                //     usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\r\n                // });\r\n\r\n                // commandEncoder = this.device.createCommandEncoder();\r\n                // commandEncoder.copyBufferToBuffer(treeBuffer, 0, dbgBuffer, 0, dbgBuffer.size);\r\n                // this.device.queue.submit([commandEncoder.finish()]);\r\n                // await this.device.queue.onSubmittedWorkDone();\r\n\r\n                // await dbgBuffer.mapAsync(GPUMapMode.READ);\r\n\r\n                // var debugValsf = new Float32Array(dbgBuffer.getMappedRange());\r\n                // console.log(debugValsf);\r\n\r\n\r\n                // var dbgBufferu = this.device.createBuffer({\r\n                //     size: stackBuffer.size,\r\n                //     usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\r\n                // });\r\n\r\n                // commandEncoder = this.device.createCommandEncoder();\r\n                // commandEncoder.copyBufferToBuffer(stackBuffer, 0, dbgBufferu, 0, stackBuffer.size);\r\n                // this.device.queue.submit([commandEncoder.finish()]);\r\n                // await this.device.queue.onSubmittedWorkDone();\r\n\r\n                // await dbgBufferu.mapAsync(GPUMapMode.READ);\r\n\r\n                // var debugValsu = new Uint32Array(dbgBufferu.getMappedRange());\r\n                // console.log(debugValsu);\r\n            }\r\n\r\n            commandEncoder = this.device.createCommandEncoder();\r\n            commandEncoder.copyBufferToBuffer(bounding2, 0, rangeBuffer, 0, 4 * 4);\r\n\r\n            start = performance.now();\r\n            computePassEncoder = commandEncoder.beginComputePass();\r\n            //commandEncoder.writeTimestamp();\r\n\r\n\r\n            // Run apply forces pass\r\n            computePassEncoder.setBindGroup(0, applyBindGroup);\r\n            computePassEncoder.setPipeline(this.applyForcesPipeline);\r\n            computePassEncoder.dispatchWorkgroups(Math.ceil(this.nodeLength / (2 * 128)), 1, 1);\r\n            computePassEncoder.end();\r\n\r\n            this.device.queue.submit([commandEncoder.finish()]);\r\n            if (debug) {await this.device.queue.onSubmittedWorkDone();}\r\n            end = performance.now();\r\n            console.log(`apply forces time ${end - start}`)\r\n            // iterationTimes.push(end - start);\r\n\r\n            // this.maxForceResultBuffer.unmap();\r\n            // Read all of the forces applied.\r\n            // await gpuReadBuffer.mapAsync(GPUMapMode.READ);\r\n            // const arrayBuffer = gpuReadBuffer.getMappedRange();\r\n            // const output = new Int32Array(arrayBuffer);\r\n            // console.log(output);\r\n\r\n            // console.log(output[23]);\r\n            // await gpuReadBuffer3.mapAsync(GPUMapMode.READ);\r\n            // const arrayBuffer3 = gpuReadBuffer3.getMappedRange();\r\n            // const output3 = new Float32Array(arrayBuffer3);\r\n            // console.log(output3);\r\n            // await gpuReadBuffer2.mapAsync(GPUMapMode.READ);\r\n            // const arrayBuffer2 = gpuReadBuffer2.getMappedRange();\r\n            // const output2 = new Uint32Array(arrayBuffer2);\r\n            // console.log(output2);\r\n            // for (var m = 0; m < output.length; m += 12) {\r\n            //     const mass = output[m + 10];\r\n            //     if (\r\n            //         output2[m + 4] == 1000000 ||\r\n            //         output2[m + 5] == 1000000 ||\r\n            //         output2[m + 6] == 1000000 ||\r\n            //         output2[m + 7] == 1000000 \r\n            //     ) {\r\n            //         console.log(m);\r\n            //         break;\r\n            //     }\r\n            // }\r\n            // if (output[11] > 0) {\r\n            //     break;\r\n            // }\r\n            this.coolingFactor = this.coolingFactor * 0.975;\r\n            if (debug) {await this.device.queue.onSubmittedWorkDone();}\r\n            const frameEnd = performance.now();\r\n            console.log(`Total frame time: ${frameEnd - frameStart}`);\r\n            totalTime += frameEnd - frameStart;\r\n            if (numIterations % 10 == 0) {\r\n                await this.device.queue.onSubmittedWorkDone();\r\n            }\r\n        }\r\n        await positionReadBuffer.mapAsync(GPUMapMode.READ);\r\n\r\n        await this.device.queue.onSubmittedWorkDone();\r\n        const totalEnd = performance.now();\r\n\r\n        console.log(`Completed in ${numIterations} iterations with total time ${totalEnd - totalStart} average iteration time ${(totalEnd - totalStart) / (numIterations - 1)}`);\r\n\r\n\r\n    }\r\n}\r\n","export function getBuffer(device: GPUDevice, arr: Float32Array | Uint32Array, usage = GPUBufferUsage.STORAGE) {\r\n    const desc = {\r\n        size: Math.max(Math.ceil(arr.byteLength / 4) * 4, 16),\r\n        usage,\r\n        mappedAtCreation: true\r\n    };\r\n    const buffer = device.createBuffer(desc);\r\n    const mappedRange = buffer.getMappedRange();\r\n    const writeArray = arr instanceof Uint32Array ? new Uint32Array(mappedRange) : new Float32Array(mappedRange);\r\n    writeArray.set(arr);\r\n    buffer.unmap();\r\n    return buffer;\r\n}\r\n\r\nexport function getUniformBuffer(device: GPUDevice, type = 'float', value = 0, usage = GPUBufferUsage.UNIFORM, size = 4) {\r\n    const buffer = device.createBuffer({ size, mappedAtCreation: true, usage });\r\n    const mappedRange = buffer.getMappedRange();\r\n    switch (type) {\r\n        case 'uint': new Uint32Array(mappedRange)[0] = value; break;\r\n        case 'int': new Int32Array(mappedRange)[0] = value; break;\r\n        default: new Float32Array(mappedRange)[0] = value;\r\n    }\r\n    buffer.unmap();\r\n    return buffer;\r\n}","(function(a,b){if(\"function\"==typeof define&&define.amd)define([],b);else if(\"undefined\"!=typeof exports)b();else{b(),a.FileSaver={exports:{}}.exports}})(this,function(){\"use strict\";function b(a,b){return\"undefined\"==typeof b?b={autoBom:!1}:\"object\"!=typeof b&&(console.warn(\"Deprecated: Expected third argument to be a object\"),b={autoBom:!b}),b.autoBom&&/^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(a.type)?new Blob([\"\\uFEFF\",a],{type:a.type}):a}function c(a,b,c){var d=new XMLHttpRequest;d.open(\"GET\",a),d.responseType=\"blob\",d.onload=function(){g(d.response,b,c)},d.onerror=function(){console.error(\"could not download file\")},d.send()}function d(a){var b=new XMLHttpRequest;b.open(\"HEAD\",a,!1);try{b.send()}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent(\"click\"))}catch(c){var b=document.createEvent(\"MouseEvents\");b.initMouseEvent(\"click\",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b)}}var f=\"object\"==typeof window&&window.window===window?window:\"object\"==typeof self&&self.self===self?self:\"object\"==typeof global&&global.global===global?global:void 0,a=f.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),g=f.saveAs||(\"object\"!=typeof window||window!==f?function(){}:\"download\"in HTMLAnchorElement.prototype&&!a?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement(\"a\");g=g||b.name||\"download\",j.download=g,j.rel=\"noopener\",\"string\"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target=\"_blank\")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href)},4E4),setTimeout(function(){e(j)},0))}:\"msSaveOrOpenBlob\"in navigator?function(f,g,h){if(g=g||f.name||\"download\",\"string\"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else{var i=document.createElement(\"a\");i.href=f,i.target=\"_blank\",setTimeout(function(){e(i)})}}:function(b,d,e,g){if(g=g||open(\"\",\"_blank\"),g&&(g.document.title=g.document.body.innerText=\"downloading...\"),\"string\"==typeof b)return c(b,d,e);var h=\"application/octet-stream\"===b.type,i=/constructor/i.test(f.HTMLElement)||f.safari,j=/CriOS\\/[\\d]+/.test(navigator.userAgent);if((j||h&&i||a)&&\"undefined\"!=typeof FileReader){var k=new FileReader;k.onloadend=function(){var a=k.result;a=j?a:a.replace(/^data:[^;]*;/,\"data:attachment/file;\"),g?g.location.href=a:location=a,g=null},k.readAsDataURL(b)}else{var l=f.URL||f.webkitURL,m=l.createObjectURL(b);g?g.location=m:location.href=m,g=null,setTimeout(function(){l.revokeObjectURL(m)},4E4)}});f.saveAs=g.saveAs=g,\"undefined\"!=typeof module&&(module.exports=g)});\n\n//# sourceMappingURL=FileSaver.min.js.map","import {node_vert} from './wgsl-shaders';\r\nimport {node_frag} from './wgsl-shaders';\r\nimport {edge_vert} from './wgsl-shaders';\r\nimport {edge_frag} from './wgsl-shaders';\r\nimport { Controller } from './ez_canvas_controller';\r\nimport { ForceDirected } from './force_directed';\r\nimport { getBuffer } from './utils';\r\nimport { saveAs } from 'file-saver';\r\n\r\nexport class Renderer {\r\n  public device: GPUDevice;\r\n  public forceDirected: ForceDirected | null = null;\r\n\r\n  public nodeBindGroup: GPUBindGroup | null = null;\r\n  public edgeBindGroup: GPUBindGroup | null = null;\r\n  public uniform2DBuffer: GPUBuffer | null = null;\r\n  public nodeDataBuffer: GPUBuffer | null = null;\r\n  public edgeDataBuffer: GPUBuffer | null = null;\r\n  public sourceEdgeDataBuffer: GPUBuffer | null = null;\r\n  public targetEdgeDataBuffer: GPUBuffer | null = null;\r\n  public viewBoxBuffer: GPUBuffer | null = null;\r\n  public nodePipeline: GPURenderPipeline | null = null;\r\n  public edgePipeline: GPURenderPipeline | null = null;\r\n\r\n  public nodeLength: number = 1;\r\n  public edgeLength: number = 1;\r\n  public nodeToggle: boolean = true;\r\n  public edgeToggle: boolean = true;\r\n  public canvasSize: [number, number] | null = null;\r\n  public idealLength: number = 0.005;\r\n  public coolingFactor: number = 0.985;\r\n  public iterRef: React.RefObject<HTMLLabelElement>;\r\n  public frame: (() => void) | undefined;\r\n  public edgeList: Array<number> = [];\r\n  public mortonCodeBuffer: GPUBuffer | null = null;\r\n  public energy: number = 0.1;\r\n  public theta: number = 2;\r\n  canvasRef: any;\r\n  viewExtreme: [number, number, number, number];\r\n  iterationCount: number = 1000;\r\n  context: GPUCanvasContext | null = null;\r\n  edgePositionBuffer: GPUBuffer | null = null;\r\n  nodePositionBuffer: GPUBuffer | null = null;\r\n\r\n  constructor(\r\n    device: GPUDevice,\r\n    canvasRef: React.RefObject<HTMLCanvasElement>,\r\n    iterRef: React.RefObject<HTMLLabelElement>,\r\n  ) {\r\n    this.iterRef = iterRef;\r\n    this.device = device;\r\n    this.canvasRef = canvasRef;\r\n    this.viewExtreme = [-1, -1, 2, 2];\r\n    // Check that canvas is active\r\n    if (canvasRef.current === null) return;\r\n    this.context = canvasRef.current.getContext('webgpu')!;\r\n\r\n    const devicePixelRatio = window.devicePixelRatio || 1;\r\n    \r\n    canvasRef.current.width = 800 * devicePixelRatio;\r\n    canvasRef.current.height = 800 * devicePixelRatio;\r\n    // canvasRef.current.width = 3840;\r\n    // canvasRef.current.height = 2160;\r\n    const presentationFormat: GPUTextureFormat = 'rgba8unorm';\r\n    this.canvasSize = [\r\n      canvasRef.current.width,\r\n      canvasRef.current.height\r\n    ];\r\n\r\n    this.context.configure({\r\n      device,\r\n      format: presentationFormat,\r\n      alphaMode: 'opaque',\r\n    });\r\n\r\n    this.edgeDataBuffer = device.createBuffer({\r\n      size: 4 * 4,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n      mappedAtCreation: true\r\n    });\r\n\r\n    let edgeData = [0, 0, 0.01, 0.01];\r\n    new Float32Array(this.edgeDataBuffer.getMappedRange()).set(edgeData);\r\n    this.edgeDataBuffer.unmap();\r\n\r\n    // setting it to some trivial data so that it won't fail the pipeline before edge data is available\r\n\r\n    this.edgePipeline = device.createRenderPipeline({\r\n      layout: 'auto',\r\n      vertex: {\r\n        module: device.createShaderModule({\r\n          code: edge_vert\r\n        }),\r\n        entryPoint: \"main\",\r\n        buffers: [\r\n          {\r\n            arrayStride: 2 * 4 * 1,\r\n            attributes: [{\r\n              format: \"float32x2\" as GPUVertexFormat,\r\n              offset: 0,\r\n              shaderLocation: 0\r\n            }\r\n            ]\r\n          }\r\n        ]\r\n      },\r\n      fragment: {\r\n        module: device.createShaderModule({\r\n          code: edge_frag\r\n        }),\r\n        entryPoint: \"main\",\r\n        targets: [\r\n          {\r\n            format: presentationFormat,\r\n            blend: {\r\n              color: { srcFactor: \"one\" as GPUBlendFactor, dstFactor: \"one-minus-src-alpha\" as GPUBlendFactor },\r\n              alpha: { srcFactor: \"one\" as GPUBlendFactor, dstFactor: \"one-minus-src-alpha\" as GPUBlendFactor }\r\n            },\r\n          },\r\n        ],\r\n      },\r\n      primitive: {\r\n        topology: \"line-list\" //triangle-list is default   \r\n      },\r\n      multisample: {\r\n        count: 4\r\n      }\r\n    });\r\n\r\n    const nodePositionArray = new Float32Array([\r\n      1, -1, -1, -1,\r\n      -1, 1, 1, -1,\r\n      -1, 1, 1, 1,\r\n    ]);\r\n    this.nodePositionBuffer = getBuffer(device, nodePositionArray, GPUBufferUsage.VERTEX);\r\n\r\n    const edgePositionArray = new Float32Array([0, 0, 1, 1]);\r\n    this.edgePositionBuffer = getBuffer(device, edgePositionArray, GPUBufferUsage.VERTEX);\r\n\r\n    const nodeDataArray = new Float32Array([0.5, 0.5, 0.5, 0.5]);\r\n    this.nodeDataBuffer = getBuffer(device, nodeDataArray, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC);\r\n    this.mortonCodeBuffer = device.createBuffer({\r\n      size: 4,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\r\n      mappedAtCreation: true\r\n    });\r\n    let mortonCode = [0];\r\n    new Float32Array(this.mortonCodeBuffer.getMappedRange()).set(mortonCode);\r\n    this.mortonCodeBuffer.unmap();\r\n\r\n\r\n    this.nodePipeline = device.createRenderPipeline({\r\n      layout: 'auto',\r\n      vertex: {\r\n        module: device.createShaderModule({\r\n          code: node_vert,\r\n        }),\r\n        entryPoint: 'main',\r\n        buffers: [\r\n          {\r\n            arrayStride: 2 * 4,\r\n            attributes: [\r\n              {\r\n                format: \"float32x2\" as GPUVertexFormat,\r\n                offset: 0,\r\n                shaderLocation: 0,\r\n              }\r\n            ],\r\n          },\r\n        ],\r\n      },\r\n      fragment: {\r\n        module: device.createShaderModule({\r\n          code: node_frag,\r\n        }),\r\n        entryPoint: 'main',\r\n        targets: [\r\n          {\r\n            format: presentationFormat,\r\n            blend: {\r\n              color: { srcFactor: \"one\" as GPUBlendFactor, dstFactor: \"one-minus-src-alpha\" as GPUBlendFactor },\r\n              alpha: { srcFactor: \"one\" as GPUBlendFactor, dstFactor: \"one-minus-src-alpha\" as GPUBlendFactor }\r\n            },\r\n          },\r\n        ],\r\n      },\r\n      primitive: {\r\n        topology: 'triangle-list',\r\n      },\r\n      multisample: {\r\n        count: 4\r\n      }\r\n    });\r\n\r\n    this.forceDirected = new ForceDirected(device);\r\n\r\n    this.viewBoxBuffer = device.createBuffer({\r\n      size: 4 * 4,\r\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    });\r\n\r\n    this.nodeBindGroup = device.createBindGroup({\r\n      layout: this.nodePipeline.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: {\r\n            buffer: this.viewBoxBuffer,\r\n          },\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.nodeDataBuffer,\r\n          }\r\n        },\r\n        {\r\n          binding: 2,\r\n          resource: {\r\n            buffer: this.mortonCodeBuffer,\r\n          }\r\n        }\r\n      ],\r\n    });\r\n    this.edgeBindGroup = device.createBindGroup({\r\n      layout: this.edgePipeline.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: {\r\n            buffer: this.viewBoxBuffer,\r\n          },\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.nodeDataBuffer,\r\n          }\r\n        },\r\n        {\r\n          binding: 2,\r\n          resource: {\r\n            buffer: this.edgeDataBuffer,\r\n          }\r\n        }\r\n      ],\r\n    });\r\n\r\n\r\n    const texture = device.createTexture({\r\n      size: [canvasRef.current.width, canvasRef.current.height],\r\n      sampleCount: 4,\r\n      format: presentationFormat,\r\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\r\n    });\r\n    const view = texture.createView();\r\n    const renderer = this;\r\n    this.frame = async () => {\r\n      // const start = performance.now();\r\n      // Sample is no longer the active page.\r\n      if (!canvasRef.current) return;\r\n\r\n      const renderPassDescriptor: GPURenderPassDescriptor = {\r\n        colorAttachments: [\r\n          {\r\n            view,\r\n            resolveTarget: renderer.context!.getCurrentTexture().createView(),\r\n            clearValue: { r: 1.0, g: 1.0, b: 1.0, a: 1.0 },\r\n            loadOp: 'clear' as GPULoadOp,\r\n            storeOp: \"discard\" as GPUStoreOp,\r\n          },\r\n        ],\r\n      };\r\n\r\n      const commandEncoder = device.createCommandEncoder();\r\n      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\r\n\r\n      if (this.edgeToggle) {\r\n        passEncoder.setPipeline(this.edgePipeline!);\r\n        passEncoder.setVertexBuffer(0, renderer.edgePositionBuffer!);\r\n        passEncoder.setBindGroup(0, this.edgeBindGroup!);\r\n        passEncoder.draw(2, this.edgeLength / 2, 0, 0);\r\n      }\r\n      if (this.nodeToggle) {\r\n        passEncoder.setPipeline(this.nodePipeline!);\r\n        passEncoder.setVertexBuffer(0, renderer.nodePositionBuffer!);\r\n        passEncoder.setBindGroup(0, this.nodeBindGroup!);\r\n        passEncoder.draw(6, this.nodeLength, 0, 0);\r\n      }\r\n      passEncoder.end();\r\n\r\n      device.queue.submit([commandEncoder.finish()]);\r\n    //   {\r\n    //     var dbgBuffer = this.device.createBuffer({\r\n    //         size: this.mortonCodeBuffer!.size,\r\n    //         usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\r\n    //     });\r\n\r\n    //     let commandEncoder2 = device.createCommandEncoder();\r\n    //     commandEncoder2.copyBufferToBuffer(this.mortonCodeBuffer!, 0, dbgBuffer, 0, dbgBuffer.size);\r\n    //     this.device.queue.submit([commandEncoder2.finish()]);\r\n    //     await this.device.queue.onSubmittedWorkDone();\r\n\r\n    //     await dbgBuffer.mapAsync(GPUMapMode.READ);\r\n\r\n    //     var debugValsf = new Uint32Array(dbgBuffer.getMappedRange());\r\n    //     console.log(debugValsf);\r\n    // }\r\n      // requestAnimationFrame(this.frame!);\r\n    }\r\n\r\n    this.frame();\r\n  }\r\n\r\n  async takeScreenshot() {\r\n    if (!this.canvasRef.current) return;\r\n\r\n    // Get dimensions\r\n    const width = this.canvasRef.current.width;\r\n    const height = this.canvasRef.current.height;\r\n    const bytesPerPixel = 4; // RGBA\r\n    const bufferSize = width * height * bytesPerPixel;\r\n\r\n    // Create output buffer\r\n    const outputBuffer = this.device.createBuffer({\r\n        size: bufferSize,\r\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\r\n    });\r\n\r\n    // Create a texture for capturing the frame\r\n    const captureTexture = this.device.createTexture({\r\n        size: { width, height, depthOrArrayLayers: 1 },\r\n        format: 'rgba8unorm',\r\n        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\r\n        sampleCount: 4\r\n    });\r\n\r\n    // Create a resolve texture for the screenshot\r\n    const resolveTexture = this.device.createTexture({\r\n      size: { width, height, depthOrArrayLayers: 1 },\r\n      format: 'rgba8unorm',\r\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC\r\n    });\r\n\r\n    // Modify render pass to write to capture texture\r\n    const renderPassDescriptor: GPURenderPassDescriptor = {\r\n      colorAttachments: [\r\n        {\r\n          view: captureTexture.createView(),\r\n          resolveTarget: resolveTexture.createView(),\r\n          clearValue: { r: 1.0, g: 1.0, b: 1.0, a: 1.0 },\r\n          loadOp: 'clear' as GPULoadOp,\r\n          storeOp: \"discard\" as GPUStoreOp,\r\n        },\r\n      ],\r\n    };\r\n\r\n    // Create command encoder and render\r\n    const commandEncoder = this.device.createCommandEncoder();\r\n    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\r\n\r\n    // Draw edges\r\n    if (this.edgeToggle) {\r\n        passEncoder.setPipeline(this.edgePipeline!);\r\n        passEncoder.setVertexBuffer(0, this.edgePositionBuffer);\r\n        passEncoder.setBindGroup(0, this.edgeBindGroup!);\r\n        passEncoder.draw(2, this.edgeLength / 2, 0, 0);\r\n    }\r\n\r\n    // Draw nodes\r\n    if (this.nodeToggle) {\r\n        passEncoder.setPipeline(this.nodePipeline!);\r\n        passEncoder.setVertexBuffer(0, this.nodePositionBuffer);\r\n        passEncoder.setBindGroup(0, this.nodeBindGroup!);\r\n        passEncoder.draw(6, this.nodeLength, 0, 0);\r\n    }\r\n\r\n    passEncoder.end();\r\n\r\n    // Copy texture to buffer\r\n    commandEncoder.copyTextureToBuffer(\r\n        {\r\n            texture: resolveTexture,\r\n            mipLevel: 0,\r\n            origin: { x: 0, y: 0, z: 0 }\r\n        },\r\n        {\r\n            buffer: outputBuffer,\r\n            bytesPerRow: width * bytesPerPixel,\r\n            rowsPerImage: height,\r\n        },\r\n        {\r\n            width: width,\r\n            height: height,\r\n            depthOrArrayLayers: 1\r\n        }\r\n    );\r\n\r\n    // Submit commands and wait for completion\r\n    this.device.queue.submit([commandEncoder.finish()]);\r\n    await this.device.queue.onSubmittedWorkDone();\r\n\r\n    // Map the buffer and read pixels\r\n    await outputBuffer.mapAsync(GPUMapMode.READ);\r\n    const pixelData = new Uint8Array(outputBuffer.getMappedRange());\r\n\r\n    // Create canvas and draw pixels\r\n    const canvas = document.createElement('canvas');\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n    const ctx = canvas.getContext('2d')!;\r\n    const imageData = ctx.createImageData(width, height);\r\n    imageData.data.set(pixelData);\r\n    ctx.putImageData(imageData, 0, 0);\r\n\r\n    canvas.toBlob(function (b) {\r\n        saveAs(b!, `out.png`);\r\n    }, \"image/png\");\r\n\r\n    // Cleanup\r\n    outputBuffer.unmap();\r\n    captureTexture.destroy();\r\n}\r\n\r\n  setNodeEdgeData(nodeData: Array<number>, edgeData: Array<number>, sourceEdges: Array<number>, targetEdges: Array<number>) {\r\n    // function randn_bm(mean, sigma) {\r\n    //   const u = 0, v = 0;\r\n    //   while(u === 0) u = Math.random(); //Converting [0,1) to (0,1)\r\n    //   while(v === 0) v = Math.random();\r\n    //   const mag = sigma * Math.sqrt(-2.0 * Math.log(u));\r\n    //   return mag * Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v ) + mean;\r\n    // }\r\n    // const N = 100000;\r\n    // const clusters = 10;\r\n    // const edgeData : Array<number> = [];\r\n    // const nodeData : Array<number> = [];\r\n    // for (const x = 0; x < N; x++) {\r\n    //   nodeData.push(0.0, 0.0, 0.0, 1.0);\r\n    // } \r\n    // for (const i = 0; i < clusters; i++){\r\n    //   for (const j = 0; j < N * 2; j++) {\r\n    //     const source = Math.floor(Math.random() * (N / clusters)) + i * (N / clusters);\r\n    //     const target = Math.floor(Math.random() * (N / clusters)) + i * (N / clusters);\r\n    //     if (!nodeData[source * 4 + 1]){\r\n    //         nodeData[source * 4 + 1] = Math.random();\r\n    //         nodeData[source * 4 + 2] = Math.random();\r\n    //     }\r\n    //     edgeData.push(source, target);\r\n    //   }\r\n    // }\r\n    // console.log(\"nodes length\" + nodeData.length / 4);\r\n    // console.log(\"edges_length\" + edgeData.length / 2);\r\n    this.edgeList = edgeData;\r\n    this.nodeDataBuffer = this.device.createBuffer({\r\n      size: nodeData.length * 4,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n      mappedAtCreation: true,\r\n    });\r\n    new Float32Array(this.nodeDataBuffer.getMappedRange()).set(nodeData);\r\n    this.nodeDataBuffer.unmap();\r\n    this.mortonCodeBuffer = this.device.createBuffer({\r\n      size: nodeData.length,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\r\n    });\r\n    this.edgeDataBuffer = this.device.createBuffer({\r\n      size: edgeData.length * 4,\r\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\r\n      mappedAtCreation: true\r\n    });\r\n    new Uint32Array(this.edgeDataBuffer.getMappedRange()).set(edgeData);\r\n    this.edgeDataBuffer.unmap();\r\n    this.edgeBindGroup = this.device.createBindGroup({\r\n      layout: this.edgePipeline!.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: {\r\n            buffer: this.viewBoxBuffer!,\r\n          },\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.nodeDataBuffer!,\r\n          }\r\n        },\r\n        {\r\n          binding: 2,\r\n          resource: {\r\n            buffer: this.edgeDataBuffer!,\r\n          }\r\n        }\r\n      ],\r\n    });\r\n    this.nodeBindGroup = this.device.createBindGroup({\r\n      layout: this.nodePipeline!.getBindGroupLayout(0),\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: {\r\n            buffer: this.viewBoxBuffer!,\r\n          },\r\n        },\r\n        {\r\n          binding: 1,\r\n          resource: {\r\n            buffer: this.nodeDataBuffer!,\r\n          }\r\n        },\r\n        {\r\n          binding: 2,\r\n          resource: {\r\n            buffer: this.mortonCodeBuffer!,\r\n          }\r\n        }\r\n      ],\r\n    });\r\n    this.edgeLength = edgeData.length;\r\n    this.nodeLength = nodeData.length / 4;\r\n    this.viewExtreme = [Math.min(-1, -(this.nodeLength / 100000)), Math.min(-1, -(this.nodeLength / 100000)), Math.max(2, 2 * (this.nodeLength / 100000)), Math.max(2, 2 * (this.nodeLength / 100000))];\r\n    this.device.queue.writeBuffer(this.viewBoxBuffer!, 0, new Float32Array(this.viewExtreme), 0, 4);\r\n    this.setController();\r\n    this.sourceEdgeDataBuffer = this.device.createBuffer({\r\n      size: edgeData.length * 4,\r\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\r\n      mappedAtCreation: true\r\n    });\r\n    new Uint32Array(this.sourceEdgeDataBuffer.getMappedRange()).set(sourceEdges);\r\n    this.sourceEdgeDataBuffer.unmap();\r\n    this.targetEdgeDataBuffer = this.device.createBuffer({\r\n      size: edgeData.length * 4,\r\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,\r\n      mappedAtCreation: true\r\n    });\r\n    new Uint32Array(this.targetEdgeDataBuffer.getMappedRange()).set(targetEdges);\r\n    this.targetEdgeDataBuffer.unmap();\r\n    requestAnimationFrame(this.frame!);\r\n  }\r\n\r\n  setCoolingFactor(value: number) {\r\n    this.coolingFactor = value;\r\n  }\r\n\r\n  setIdealLength(value: number) {\r\n    this.idealLength = value;\r\n  }\r\n\r\n  setEnergy(value: number) {\r\n    this.energy = value;\r\n  }\r\n\r\n  setIterationCount(value: number) {\r\n    this.iterationCount = value;\r\n  }\r\n\r\n  setTheta(value: number) {\r\n    this.theta = value;\r\n  }\r\n\r\n  async runForceDirected() {\r\n    // this.forceDirected!.runForces(\r\n    //   this.nodeDataBuffer!, this.edgeDataBuffer!, this.mortonCodeBuffer!, this.nodeLength, this.edgeLength,\r\n    //   this.coolingFactor, this.idealLength, this.energy, this.theta, this.iterationCount, 100,\r\n    //   this.sourceEdgeDataBuffer, this.targetEdgeDataBuffer, this.frame!\r\n    // );\r\n  }\r\n\r\n  async stopForceDirected() {\r\n    this.forceDirected!.stopForces();\r\n  }\r\n\r\n  toggleNodeLayer() {\r\n    this.nodeToggle = !this.nodeToggle;\r\n  }\r\n\r\n  toggleEdgeLayer() {\r\n    this.edgeToggle = !this.edgeToggle;\r\n  }\r\n\r\n  setController() {\r\n    let translation = this.viewExtreme;\r\n    let newTranslation = this.viewExtreme;\r\n    const controller = new Controller();\r\n    controller.mousemove = (prev, cur, evt) => {\r\n      if (evt.buttons === 1) {\r\n        const change = [(cur[0] - prev[0]) * (translation[2] - translation[0]) / this.canvasSize![0], (prev[1] - cur[1]) * (translation[3] - translation[1]) / this.canvasSize![1]];\r\n        newTranslation = [newTranslation[0] - change[0], newTranslation[1] - change[1], newTranslation[2] - change[0], newTranslation[3] - change[1]]\r\n        if (Math.abs(newTranslation[0] - translation[0]) > 0.03 * (translation[2] - translation[0]) || Math.abs(newTranslation[1] - translation[1]) > 0.03 * (translation[3] - translation[1])) {\r\n          translation = newTranslation;\r\n          this.device.queue.writeBuffer(this.viewBoxBuffer!, 0, new Float32Array(translation), 0, 4);\r\n          requestAnimationFrame(this.frame!);\r\n        }\r\n      }\r\n    };\r\n    controller.wheel = (amt) => {\r\n      const change = [amt / 1000, amt / 1000];\r\n      newTranslation = [newTranslation[0] + change[0], newTranslation[1] + change[1], newTranslation[2] - change[0], newTranslation[3] - change[1]];\r\n      if (newTranslation[2] - newTranslation[0] > 0.01 && newTranslation[3] - newTranslation[1] > 0.01) {\r\n        translation = newTranslation;\r\n        this.device.queue.writeBuffer(this.viewBoxBuffer!, 0, new Float32Array(translation), 0, 4);\r\n        requestAnimationFrame(this.frame!);\r\n      } else {\r\n        newTranslation = translation;\r\n      }\r\n    };\r\n    controller.registerForCanvas(this.canvasRef.current!);\r\n  }\r\n}\r\n\r\n"],"names":["apply_forces","compute_attractive_new","compute_forcesBH","create_sourcelist","create_targetlist","create_tree","edge_frag","edge_vert","morton_codes","node_frag","node_vert","radix_sort","Controller","__publicField","canvas","prevMouse","self","evt","rect","curMouse","HISTOGRAM_WG_SIZE","PREFIX_WG_SIZE","SCATTER_WG_SIZE","RS_RADIX_LOG2","RS_RADIX_SIZE","RS_KEYVAL_SIZE","RS_HISTOGRAM_BLOCK_ROWS","RS_SCATTER_BLOCK_ROWS","SCATTER_BLOCK_KVS","HISTO_BLOCK_KVS","BYTES_PER_PAYLOAD_ELEM","NUM_PASSES","GPUSorter","device","subgroupSize","histogram_sg_size","rs_sweep_0_size","rs_sweep_1_size","rs_mem_dwords","rs_mem_sweep_0_offset","rs_mem_sweep_1_offset","rs_mem_sweep_2_offset","pipelineLayout","shader_code","shader","length","count_ru_histo","keys","keys_aux","payload_size","payload","payload_aux","s_b_ru","histo_size","internal_size","keysA","keysB","payloadA","payloadB","internalMemBuffer","uniform_infos","uniformBuffer","uniformData","bindGroup","SortBuffers","commandEncoder","histBlocksRu","passEncoder","passEncoder2","scatterBlocksRu","queue","sortBuffers","sortFirstN","numElements","n","ForceDirected","positionList","edgeList","nLength","eLength","nodeArray","edgeArray","i","sourceIndex","targetIndex","nodes","edges","edges2","sortedBySource","a","b","edge","sortedByTarget","coolingFactor","l","theta","iterationCount","rangeBuffer","bounding","mapping","bounding2","mapping2","uploadBuffer","treeInfoBuffer","sourceListBuffer","targetListBuffer","edgeInfoBuffer","treeBuffer","createSourceListBindGroup","createTargetListBindGroup","computePassEncoder","gpuReadBuffer","applyBindGroup","createTreeBindGroup","mortonCodeBindGroup","positionReadBuffer","numIterations","start","end","totalStart","frameStart","upload","dbgBufferu","debugValsu","sortEncoder","dbgBuffer","startTot","maxIndex","endTot","computeForcesBHBindGroup","attractBindGroup","pass","frameEnd","totalEnd","getBuffer","arr","usage","desc","buffer","mappedRange","this","c","d","g","e","f","global","h","j","k","m","module","Renderer","canvasRef","iterRef","devicePixelRatio","presentationFormat","edgeData","nodePositionArray","edgePositionArray","nodeDataArray","mortonCode","view","renderer","renderPassDescriptor","width","height","bytesPerPixel","bufferSize","outputBuffer","captureTexture","resolveTexture","pixelData","ctx","imageData","saveAs","nodeData","sourceEdges","targetEdges","value","translation","newTranslation","controller","prev","cur","change","amt"],"mappings":";;;AAGO,MAAMA,KAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GA2FfC,KAAyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IA2LzBC,KAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAsKnBC,KAAoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IA6CpBC,KAAoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IA6CpBC,KAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAmLdC,KAAY;AAAA;AAAA;AAAA,IAKZC,KAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAsCZC,KAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GA+LfC,KAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAaZC,KAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAoFZC,KAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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","x_google_ignoreList":[5]}